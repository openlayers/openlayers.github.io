{"version":3,"file":"contour-interpolation.js","mappings":";;;;;;;;;;;;;;;;AAAmC;AACE;AAC0B;AACV;AAC0B;AACxB;AACmB;;AAE1E;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,yBAAyB;;AAElE,mBAAmB,kEAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B,sBAAsB,OAAO;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mFAAmF,EAAE,GAAG,GAAG,GAAG,GAAG;AACjG,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,sBAAsB,OAAO;AAC7B,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,YAAY;AACzC;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH,CAAC;AACD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,iEAAS;AAChC;AACA;AACA,CAAC;AACD,uBAAuB,iEAAS;AAChC;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,iBAAiB;AACpC,qBAAqB,gBAAgB;AACrC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;;AAEA,0BAA0B,mEAAY;AACtC;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA,CAAC;;AAED,yBAAyB,iEAAU;AACnC;AACA;AACA,CAAC;;AAED,2BAA2B,iEAAU;AACrC,cAAc,mEAAY;AAC1B;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;AACA,CAAC;;AAED,sBAAsB,iEAAS;AAC/B;AACA,UAAU,6BAA6B;AACvC,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED,gBAAgB,+DAAG;AACnB;AACA,QAAQ,iEAAS;AACjB,kBAAkB,kEAAG;AACrB,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,YAAY,iEAAI;AAChB,YAAY,qEAAU;AACtB;AACA;AACA,GAAG;AACH,CAAC;;AAED,iCAAiC,iFAAa;AAC9C;AACA;AACA;AACA;AACA,iCAAiC,6EAAY,CAAC,mEAAQ;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,CAAC;AACD","sources":["webpack:///./contour-interpolation.js"],"sourcesContent":["import Map from '../src/ol/Map.js';\nimport View from '../src/ol/View.js';\nimport MousePosition from '../src/ol/control/MousePosition.js';\nimport {toStringHDMS} from '../src/ol/coordinate.js';\nimport {Image as ImageLayer, WebGLTile as TileLayer} from '../src/ol/layer.js';\nimport {fromLonLat, toLonLat} from '../src/ol/proj.js';\nimport {DataTile, OSM, Raster as RasterSource} from '../src/ol/source.js';\n\nconst attribution =\n  '<a href=\"https://github.com/tilezen/joerd/blob/master/docs/attribution.md\" target=\"_blank\">Data sources and attribution</a>';\n\nconst calculateElevation = function (pixel) {\n  if (pixel[3]) {\n    return -32768 + (pixel[0] * 256 + pixel[1] + pixel[2] / 256);\n  }\n};\n\n// Use Float32 interpolation where supported for best results on mobile devices.\nconst calculateElevationFromData = function (pixel) {\n  return pixel[0];\n};\nconst elevation = ['band', 1];\nconst tileSize = 256;\nconst gutter = 1;\nconst canvas = document.createElement('canvas');\ncanvas.width = tileSize * 3;\ncanvas.height = tileSize * 3;\nconst context = canvas.getContext('2d', {willReadFrequently: true});\n\nconst source = new DataTile({\n  attributions: attribution,\n  tileSize: tileSize,\n  gutter: gutter,\n  maxZoom: 15,\n  interpolate: true,\n  wrapX: true,\n  loader: (z, x, y) => {\n    const promises = [];\n    for (let i = 0; i < 3; ++i) {\n      for (let j = 0; j < 3; ++j) {\n        promises.push(\n          new Promise((resolve, reject) => {\n            const maxY = 2 ** z;\n            const yy = y + j - 1;\n            if (yy < 0 || yy >= maxY) {\n              return resolve();\n            }\n            const maxX = 2 ** z;\n            const xx = (((x + i - 1) % maxX) + maxX) % maxX;\n            const image = new Image();\n            image.crossOrigin = '';\n            image.addEventListener('error', () => reject());\n            image.addEventListener('load', () => resolve(image));\n            image.src = `https://s3.amazonaws.com/elevation-tiles-prod/terrarium/${z}/${xx}/${yy}.png`;\n          }),\n        );\n      }\n    }\n    return Promise.all(promises).then((images) => {\n      context.clearRect(0, 0, canvas.width, canvas.height);\n      for (let i = 0; i < 3; ++i) {\n        for (let j = 0; j < 3; ++j) {\n          const image = images.shift();\n          if (image) {\n            context.drawImage(image, i * tileSize, j * tileSize);\n          }\n        }\n      }\n      const data = context.getImageData(\n        tileSize - gutter,\n        tileSize - gutter,\n        tileSize + 2 * gutter,\n        tileSize + 2 * gutter,\n      ).data;\n      const pixels = data.length / 4;\n      const floatData = new Float32Array(data.buffer);\n      for (let i = 0, j = 0; i < pixels; ) {\n        floatData[i++] = calculateElevation(data.slice(j, (j += 4)));\n      }\n      return floatData;\n    });\n  },\n});\nconst pixelValue = ['*', ['+', elevation, 32768], 256];\n\nconst style = {\n  color: [\n    'array',\n    ['/', ['floor', ['/', pixelValue, 256 * 256]], 255],\n    ['/', ['floor', ['/', ['%', pixelValue, 256 * 256], 256]], 255],\n    ['/', ['%', pixelValue, 256], 255],\n    1,\n  ],\n};\n\n/// duplicate layers as one layer shared by two raster sources causes rendering issues\nconst elevation1 = new TileLayer({\n  source: source,\n  style: style,\n});\nconst elevation2 = new TileLayer({\n  source: source,\n  style: style,\n});\n\nconst contours = function (inputs, data) {\n  const elevationImage = inputs[0];\n  const width = elevationImage.width;\n  const height = elevationImage.height;\n  const elevationData = elevationImage.data;\n  const pixel = [0, 0, 0, 0];\n  const contourData = new Uint8ClampedArray(elevationData.length);\n  const interval = data.interval;\n\n  let offset, pixelY, pixelX;\n  for (pixelY = 0; pixelY < height; ++pixelY) {\n    for (pixelX = 0; pixelX < width; ++pixelX) {\n      offset = (pixelY * width + Math.max(pixelX - 1, 0)) * 4;\n      pixel[0] = elevationData[offset];\n      pixel[1] = elevationData[offset + 1];\n      pixel[2] = elevationData[offset + 2];\n      pixel[3] = elevationData[offset + 3];\n      const leftElevation = calculateElevation(pixel);\n\n      offset = (pixelY * width + Math.min(pixelX + 1, width - 1)) * 4;\n      pixel[0] = elevationData[offset];\n      pixel[1] = elevationData[offset + 1];\n      pixel[2] = elevationData[offset + 2];\n      pixel[3] = elevationData[offset + 3];\n      const rightElevation = calculateElevation(pixel);\n\n      offset = (Math.max(pixelY - 1, 0) * width + pixelX) * 4;\n      pixel[0] = elevationData[offset];\n      pixel[1] = elevationData[offset + 1];\n      pixel[2] = elevationData[offset + 2];\n      pixel[3] = elevationData[offset + 3];\n      const topElevation = calculateElevation(pixel);\n\n      offset = (Math.min(pixelY + 1, height - 1) * width + pixelX) * 4;\n      pixel[0] = elevationData[offset];\n      pixel[1] = elevationData[offset + 1];\n      pixel[2] = elevationData[offset + 2];\n      pixel[3] = elevationData[offset + 3];\n      const bottomElevation = calculateElevation(pixel);\n\n      offset = (pixelY * width + pixelX) * 4;\n      pixel[0] = elevationData[offset];\n      pixel[1] = elevationData[offset + 1];\n      pixel[2] = elevationData[offset + 2];\n      pixel[3] = elevationData[offset + 3];\n      const centerElevation = calculateElevation(pixel);\n\n      if (\n        leftElevation !== undefined &&\n        rightElevation !== undefined &&\n        topElevation !== undefined &&\n        bottomElevation !== undefined &&\n        centerElevation !== undefined\n      ) {\n        const contour = Math.floor(centerElevation / interval);\n        if (\n          contour !== Math.floor(leftElevation / interval) ||\n          contour !== Math.floor(rightElevation / interval) ||\n          contour !== Math.floor(topElevation / interval) ||\n          contour !== Math.floor(bottomElevation / interval)\n        ) {\n          if (\n            centerElevation > 0 &&\n            leftElevation > 0 &&\n            rightElevation > 0 &&\n            topElevation > 0 &&\n            bottomElevation > 0\n          ) {\n            contourData[offset] = 0xe0;\n            contourData[offset + 1] = 0x94;\n            contourData[offset + 2] = 0x5e;\n            contourData[offset + 3] = 255;\n          } else {\n            contourData[offset] = 0x00;\n            contourData[offset + 1] = 0xa9;\n            contourData[offset + 2] = 0xca;\n            contourData[offset + 3] = 255;\n          }\n        }\n      }\n    }\n  }\n  return {data: contourData, width: width, height: height};\n};\n\nconst contourSource = new RasterSource({\n  sources: [elevation1],\n  operationType: 'image',\n  operation: contours,\n  lib: {\n    calculateElevation: calculateElevation,\n  },\n  resolutions: null,\n});\n\ncontourSource.on('beforeoperations', function (event) {\n  const data = event.data;\n  if (event.resolution < 5) {\n    data.interval = 10;\n  } else if (event.resolution < 25) {\n    data.interval = 50;\n  } else if (event.resolution < 50) {\n    data.interval = 100;\n  } else if (event.resolution < 250) {\n    data.interval = 500;\n  } else {\n    data.interval = 1000;\n  }\n});\n\nconst contourLayer = new ImageLayer({\n  source: contourSource,\n  opacity: 0.5,\n});\n\nconst elevationLayer = new ImageLayer({\n  source: new RasterSource({\n    sources: [elevation2],\n    operation: function (pixels) {\n      return pixels[0];\n    },\n    resolutions: null,\n  }),\n  opacity: 0,\n});\n\nconst dataLayer = new TileLayer({\n  source: source,\n  style: {color: ['array', 0, 0, 0, 0]},\n});\n\ndataLayer.once('postrender', function (event) {\n  const gl = event.context;\n  if (!gl.getSupportedExtensions().includes('OES_texture_float_linear')) {\n    alert('Device does not support float interpolation');\n  }\n});\n\nconst map = new Map({\n  layers: [\n    new TileLayer({\n      source: new OSM(),\n    }),\n    dataLayer,\n    contourLayer,\n    elevationLayer,\n  ],\n  target: 'map',\n  view: new View({\n    center: fromLonLat([-78.8175, -1.469167]),\n    zoom: 17,\n    maxZoom: 21,\n  }),\n});\n\nconst mousePositionControl = new MousePosition({\n  className: 'custom-mouse-position',\n  target: 'info',\n  wrapX: false,\n  coordinateFormat: function (coordinate) {\n    let position = 'Position ' + toStringHDMS(toLonLat(coordinate)) + '<br>';\n    let pixel = elevationLayer.getData(map.getPixelFromCoordinate(coordinate));\n    if (pixel) {\n      const elevation = calculateElevation(pixel);\n      if (elevation !== undefined) {\n        position += 'Elevation ' + elevation.toFixed(1) + ' meters';\n      }\n    }\n    position += '<br><br>';\n\n    pixel = dataLayer.getData(map.getPixelFromCoordinate(coordinate));\n    if (pixel) {\n      const elevation = calculateElevationFromData(pixel);\n      if (elevation !== undefined) {\n        position += 'Data value ' + elevation.toFixed(1) + ' meters';\n      }\n    }\n    position += '<br>';\n    return position;\n  },\n  placeholder: '<br><br><br><br>',\n});\nmap.addControl(mousePositionControl);\n"],"names":[],"sourceRoot":""}