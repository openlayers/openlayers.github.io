"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[6803],{34996:function(t,e,n){function o(t,e,n,s){let r=s;const l=e+(n-e>>1);let u,c=n-e;const f=t[e],a=t[e+1],g=t[n],m=t[n+1];for(let o=e+3;o<n;o+=3){const e=i(t[o],t[o+1],f,a,g,m);if(e>r)u=o,r=e;else if(e===r){const t=Math.abs(o-l);t<c&&(u=o,c=t)}}r>s&&(u-e>3&&o(t,e,u,s),t[u+2]=r,n-u>3&&o(t,u,n,s))}function i(t,e,n,o,i,s){let r=i-n,l=s-o;if(0!==r||0!==l){const u=((t-n)*r+(e-o)*l)/(r*r+l*l);u>1?(n=i,o=s):u>0&&(n+=r*u,o+=l*u)}return r=t-n,l=e-o,r*r+l*l}function s(t,e,n,o){const i={id:null==t?null:t,type:e,geometry:n,tags:o,minX:1/0,minY:1/0,maxX:-1/0,maxY:-1/0};if("Point"===e||"MultiPoint"===e||"LineString"===e)r(i,n);else if("Polygon"===e)r(i,n[0]);else if("MultiLineString"===e)for(const t of n)r(i,t);else if("MultiPolygon"===e)for(const t of n)r(i,t[0]);return i}function r(t,e){for(let n=0;n<e.length;n+=3)t.minX=Math.min(t.minX,e[n]),t.minY=Math.min(t.minY,e[n+1]),t.maxX=Math.max(t.maxX,e[n]),t.maxY=Math.max(t.maxY,e[n+1])}function l(t,e,n,o){if(!e.geometry)return;const i=e.geometry.coordinates;if(i&&0===i.length)return;const r=e.geometry.type,a=Math.pow(n.tolerance/((1<<n.maxZoom)*n.extent),2);let g=[],m=e.id;if(n.promoteId?m=e.properties[n.promoteId]:n.generateId&&(m=o||0),"Point"===r)u(i,g);else if("MultiPoint"===r)for(const t of i)u(t,g);else if("LineString"===r)c(i,g,a,!1);else if("MultiLineString"===r){if(n.lineMetrics){for(const n of i)g=[],c(n,g,a,!1),t.push(s(m,"LineString",g,e.properties));return}f(i,g,a,!1)}else if("Polygon"===r)f(i,g,a,!0);else{if("MultiPolygon"!==r){if("GeometryCollection"===r){for(const i of e.geometry.geometries)l(t,{id:m,geometry:i,properties:e.properties},n,o);return}throw new Error("Input data is not a valid GeoJSON object.")}for(const t of i){const e=[];f(t,e,a,!0),g.push(e)}}t.push(s(m,r,g,e.properties))}function u(t,e){e.push(a(t[0]),g(t[1]),0)}function c(t,e,n,i){let s,r,l=0;for(let n=0;n<t.length;n++){const o=a(t[n][0]),u=g(t[n][1]);e.push(o,u,0),n>0&&(l+=i?(s*u-o*r)/2:Math.sqrt(Math.pow(o-s,2)+Math.pow(u-r,2))),s=o,r=u}const u=e.length-3;e[2]=1,o(e,0,u,n),e[u+2]=1,e.size=Math.abs(l),e.start=0,e.end=e.size}function f(t,e,n,o){for(let i=0;i<t.length;i++){const s=[];c(t[i],s,n,o),e.push(s)}}function a(t){return t/360+.5}function g(t){const e=Math.sin(t*Math.PI/180),n=.5-.25*Math.log((1+e)/(1-e))/Math.PI;return n<0?0:n>1?1:n}function m(t,e,n,o,i,r,l,u){if(o/=e,r>=(n/=e)&&l<o)return t;if(l<n||r>=o)return null;const c=[];for(const e of t){const t=e.geometry;let r=e.type;const l=0===i?e.minX:e.minY,f=0===i?e.maxX:e.maxY;if(l>=n&&f<o){c.push(e);continue}if(f<n||l>=o)continue;let a=[];if("Point"===r||"MultiPoint"===r)h(t,a,n,o,i);else if("LineString"===r)p(t,a,n,o,i,!1,u.lineMetrics);else if("MultiLineString"===r)x(t,a,n,o,i,!1);else if("Polygon"===r)x(t,a,n,o,i,!0);else if("MultiPolygon"===r)for(const e of t){const t=[];x(e,t,n,o,i,!0),t.length&&a.push(t)}if(a.length){if(u.lineMetrics&&"LineString"===r){for(const t of a)c.push(s(e.id,r,t,e.tags));continue}"LineString"!==r&&"MultiLineString"!==r||(1===a.length?(r="LineString",a=a[0]):r="MultiLineString"),"Point"!==r&&"MultiPoint"!==r||(r=3===a.length?"Point":"MultiPoint"),c.push(s(e.id,r,a,e.tags))}}return c.length?c:null}function h(t,e,n,o,i){for(let s=0;s<t.length;s+=3){const r=t[s+i];r>=n&&r<=o&&y(e,t[s],t[s+1],t[s+2])}}function p(t,e,n,o,i,s,r){let l=d(t);const u=0===i?M:P;let c,f,a=t.start;for(let g=0;g<t.length-3;g+=3){const m=t[g],h=t[g+1],p=t[g+2],x=t[g+3],M=t[g+4],P=0===i?m:h,S=0===i?x:M;let w=!1;r&&(c=Math.sqrt(Math.pow(m-x,2)+Math.pow(h-M,2))),P<n?S>n&&(f=u(l,m,h,x,M,n),r&&(l.start=a+c*f)):P>o?S<o&&(f=u(l,m,h,x,M,o),r&&(l.start=a+c*f)):y(l,m,h,p),S<n&&P>=n&&(f=u(l,m,h,x,M,n),w=!0),S>o&&P<=o&&(f=u(l,m,h,x,M,o),w=!0),!s&&w&&(r&&(l.end=a+c*f),e.push(l),l=d(t)),r&&(a+=c)}let g=t.length-3;const m=t[g],h=t[g+1],p=t[g+2],x=0===i?m:h;x>=n&&x<=o&&y(l,m,h,p),g=l.length-3,s&&g>=3&&(l[g]!==l[0]||l[g+1]!==l[1])&&y(l,l[0],l[1],l[2]),l.length&&e.push(l)}function d(t){const e=[];return e.size=t.size,e.start=t.start,e.end=t.end,e}function x(t,e,n,o,i,s){for(const r of t)p(r,e,n,o,i,s,!1)}function y(t,e,n,o){t.push(e,n,o)}function M(t,e,n,o,i,s){const r=(s-e)/(o-e);return y(t,s,n+(i-n)*r,1),r}function P(t,e,n,o,i,s){const r=(s-n)/(i-n);return y(t,e+(o-e)*r,s,1),r}function S(t,e){const n=[];for(let o=0;o<t.length;o++){const i=t[o],r=i.type;let l;if("Point"===r||"MultiPoint"===r||"LineString"===r)l=w(i.geometry,e);else if("MultiLineString"===r||"Polygon"===r){l=[];for(const t of i.geometry)l.push(w(t,e))}else if("MultiPolygon"===r){l=[];for(const t of i.geometry){const n=[];for(const o of t)n.push(w(o,e));l.push(n)}}n.push(s(i.id,r,l,i.tags))}return n}function w(t,e){const n=[];n.size=t.size,void 0!==t.start&&(n.start=t.start,n.end=t.end);for(let o=0;o<t.length;o+=3)n.push(t[o]+e,t[o+1],t[o+2]);return n}function L(t,e){if(t.transformed)return t;const n=1<<t.z,o=t.x,i=t.y;for(const s of t.features){const t=s.geometry,r=s.type;if(s.geometry=[],1===r)for(let r=0;r<t.length;r+=2)s.geometry.push(Y(t[r],t[r+1],e,n,o,i));else for(let r=0;r<t.length;r++){const l=[];for(let s=0;s<t[r].length;s+=2)l.push(Y(t[r][s],t[r][s+1],e,n,o,i));s.geometry.push(l)}}return t.transformed=!0,t}function Y(t,e,n,o,i,s){return[Math.round(n*(t*o-i)),Math.round(n*(e*o-s))]}function X(t,e,n,o,i){const s=e===i.maxZoom?0:i.tolerance/((1<<e)*i.extent),r={features:[],numPoints:0,numSimplified:0,numFeatures:t.length,source:null,x:n,y:o,z:e,transformed:!1,minX:2,minY:1,maxX:-1,maxY:0};for(const e of t)b(r,e,s,i);return r}function b(t,e,n,o){const i=e.geometry,s=e.type,r=[];if(t.minX=Math.min(t.minX,e.minX),t.minY=Math.min(t.minY,e.minY),t.maxX=Math.max(t.maxX,e.maxX),t.maxY=Math.max(t.maxY,e.maxY),"Point"===s||"MultiPoint"===s)for(let e=0;e<i.length;e+=3)r.push(i[e],i[e+1]),t.numPoints++,t.numSimplified++;else if("LineString"===s)z(r,i,t,n,!1,!1);else if("MultiLineString"===s||"Polygon"===s)for(let e=0;e<i.length;e++)z(r,i[e],t,n,"Polygon"===s,0===e);else if("MultiPolygon"===s)for(let e=0;e<i.length;e++){const o=i[e];for(let e=0;e<o.length;e++)z(r,o[e],t,n,!0,0===e)}if(r.length){let n=e.tags||null;if("LineString"===s&&o.lineMetrics){n={};for(const t in e.tags)n[t]=e.tags[t];n.mapbox_clip_start=i.start/i.size,n.mapbox_clip_end=i.end/i.size}const l={geometry:r,type:"Polygon"===s||"MultiPolygon"===s?3:"LineString"===s||"MultiLineString"===s?2:1,tags:n};null!==e.id&&(l.id=e.id),t.features.push(l)}}function z(t,e,n,o,i,s){const r=o*o;if(o>0&&e.size<(i?r:o))return void(n.numPoints+=e.length/3);const l=[];for(let t=0;t<e.length;t+=3)(0===o||e[t+2]>r)&&(n.numSimplified++,l.push(e[t],e[t+1])),n.numPoints++;i&&function(t,e){let n=0;for(let e=0,o=t.length,i=o-2;e<o;i=e,e+=2)n+=(t[e]-t[i])*(t[e+1]+t[i+1]);if(n>0===e)for(let e=0,n=t.length;e<n/2;e+=2){const o=t[e],i=t[e+1];t[e]=t[n-2-e],t[e+1]=t[n-1-e],t[n-2-e]=o,t[n-1-e]=i}}(l,s),t.push(l)}const I={maxZoom:14,indexMaxZoom:5,indexMaxPoints:1e5,tolerance:3,extent:4096,buffer:64,lineMetrics:!1,promoteId:null,generateId:!1,debug:0};class E{constructor(t,e){const n=(e=this.options=function(t,e){for(const n in e)t[n]=e[n];return t}(Object.create(I),e)).debug;if(n&&console.time("preprocess data"),e.maxZoom<0||e.maxZoom>24)throw new Error("maxZoom should be in the 0-24 range");if(e.promoteId&&e.generateId)throw new Error("promoteId and generateId cannot be used together.");let o=function(t,e){const n=[];if("FeatureCollection"===t.type)for(let o=0;o<t.features.length;o++)l(n,t.features[o],e,o);else"Feature"===t.type?l(n,t,e):l(n,{geometry:t},e);return n}(t,e);this.tiles={},this.tileCoords=[],n&&(console.timeEnd("preprocess data"),console.log("index: maxZoom: %d, maxPoints: %d",e.indexMaxZoom,e.indexMaxPoints),console.time("generate tiles"),this.stats={},this.total=0),o=function(t,e){const n=e.buffer/e.extent;let o=t;const i=m(t,1,-1-n,n,0,-1,2,e),s=m(t,1,1-n,2+n,0,-1,2,e);return(i||s)&&(o=m(t,1,-n,1+n,0,-1,2,e)||[],i&&(o=S(i,1).concat(o)),s&&(o=o.concat(S(s,-1)))),o}(o,e),o.length&&this.splitTile(o,0,0,0),n&&(o.length&&console.log("features: %d, points: %d",this.tiles[0].numFeatures,this.tiles[0].numPoints),console.timeEnd("generate tiles"),console.log("tiles generated:",this.total,JSON.stringify(this.stats)))}splitTile(t,e,n,o,i,s,r){const l=[t,e,n,o],u=this.options,c=u.debug;for(;l.length;){o=l.pop(),n=l.pop(),e=l.pop(),t=l.pop();const f=1<<e,a=F(e,n,o);let g=this.tiles[a];if(!g&&(c>1&&console.time("creation"),g=this.tiles[a]=X(t,e,n,o,u),this.tileCoords.push({z:e,x:n,y:o}),c)){c>1&&(console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)",e,n,o,g.numFeatures,g.numPoints,g.numSimplified),console.timeEnd("creation"));const t=`z${e}`;this.stats[t]=(this.stats[t]||0)+1,this.total++}if(g.source=t,null==i){if(e===u.indexMaxZoom||g.numPoints<=u.indexMaxPoints)continue}else{if(e===u.maxZoom||e===i)continue;if(null!=i){const t=i-e;if(n!==s>>t||o!==r>>t)continue}}if(g.source=null,0===t.length)continue;c>1&&console.time("clipping");const h=.5*u.buffer/u.extent,p=.5-h,d=.5+h,x=1+h;let y=null,M=null,P=null,S=null,w=m(t,f,n-h,n+d,0,g.minX,g.maxX,u),L=m(t,f,n+p,n+x,0,g.minX,g.maxX,u);t=null,w&&(y=m(w,f,o-h,o+d,1,g.minY,g.maxY,u),M=m(w,f,o+p,o+x,1,g.minY,g.maxY,u),w=null),L&&(P=m(L,f,o-h,o+d,1,g.minY,g.maxY,u),S=m(L,f,o+p,o+x,1,g.minY,g.maxY,u),L=null),c>1&&console.timeEnd("clipping"),l.push(y||[],e+1,2*n,2*o),l.push(M||[],e+1,2*n,2*o+1),l.push(P||[],e+1,2*n+1,2*o),l.push(S||[],e+1,2*n+1,2*o+1)}}getTile(t,e,n){t=+t,e=+e,n=+n;const o=this.options,{extent:i,debug:s}=o;if(t<0||t>24)return null;const r=1<<t,l=F(t,e=e+r&r-1,n);if(this.tiles[l])return L(this.tiles[l],i);s>1&&console.log("drilling down to z%d-%d-%d",t,e,n);let u,c=t,f=e,a=n;for(;!u&&c>0;)c--,f>>=1,a>>=1,u=this.tiles[F(c,f,a)];return u&&u.source?(s>1&&(console.log("found parent tile z%d-%d-%d",c,f,a),console.time("drilling down")),this.splitTile(u.source,c,f,a,t,e,n),s>1&&console.timeEnd("drilling down"),this.tiles[l]?L(this.tiles[l],i):null):null}}function F(t,e,n){return 32*((1<<t)*n+e)+t}var Z=n(41564),C=n(87240),O=n(49208),T=n(88887),j=n(43438),v=n(98267);const A=function(t,e){if(!e||!e.geometry)return e;let n;const o=e.type;let i=e.geometry;return 1===o?(n="MultiPoint",1==i.length&&(n="Point",i=i[0])):2===o?(n="MultiLineString",1==i.length&&(n="LineString",i=i[0])):3===o&&(n="Polygon",i.length>1&&(n="MultiPolygon",i=[i])),{type:"Feature",geometry:{type:n,coordinates:i},properties:e.tags}},k=new T.A({background:"#1a2b39",style:{"fill-color":["string",["get","COLOR"],"#eee"]}}),J=new Z.A({layers:[k],target:"map",view:new C.Ay({center:[0,0],zoom:2})});fetch("https://openlayers.org/data/vector/ecoregions.json").then((function(t){return t.json()})).then((function(t){const e=new E(t,{extent:4096,debug:1});const n=new O.A({dataProjection:new j.A({code:"TILE_PIXELS",units:"tile-pixels",extent:[0,0,4096,4096]})}),o=new v.A({tileUrlFunction:function(t){return JSON.stringify(t)},tileLoadFunction:function(t,i){const s=JSON.parse(i),r=e.getTile(s[0],s[1],s[2]),l=JSON.stringify({type:"FeatureCollection",features:r?r.features:[]},A),u=n.readFeatures(l,{extent:o.getTileGrid().getTileCoordExtent(s),featureProjection:J.getView().getProjection()});t.setFeatures(u)}});k.setSource(o)}))}},function(t){var e;e=34996,t(t.s=e)}]);
//# sourceMappingURL=geojson-vt.js.map