{"version":3,"file":"clusters-dynamic.js","mappings":"yFAQe,SAASA,EAAwBC,EAAQC,EAAU,CAAC,GAC/D,MAAM,OAAEC,GAAWD,EACdC,IACDF,EAASA,EAAOG,QAAQC,KAAKC,IAEjC,MAAMC,EAAIN,EAAOO,OACXC,EAAS,IAAIC,MAAU,EAAJH,GACzB,IAAII,EAAI,EACR,IAAK,IAAIC,EAAI,EAAGA,EAAIL,EAAGK,IAAK,CACxB,MAAMC,EAAQZ,EAAOW,GACrB,KAAOD,GAAK,GAAKG,EAAGL,EAAOE,EAAI,GAAIF,EAAOE,EAAI,GAAIE,IAAU,GACxDF,IAEJF,EAAOE,KAAOE,CAClB,CACA,MAAME,EAAIJ,EAAI,EACd,IAAK,IAAIC,EAAIL,EAAI,EAAGK,GAAK,EAAGA,IAAK,CAC7B,MAAMC,EAAQZ,EAAOW,GACrB,KAAOD,GAAKI,GAAKD,EAAGL,EAAOE,EAAI,GAAIF,EAAOE,EAAI,GAAIE,IAAU,GACxDF,IAEJF,EAAOE,KAAOE,CAClB,CACA,OAAOJ,EAAOL,MAAM,EAAGO,EAAI,EAC/B,CACA,SAASG,EAAGE,EAAIC,EAAIC,GAChB,OAAQD,EAAG,GAAKD,EAAG,KAAOE,EAAG,GAAKF,EAAG,KAAOC,EAAG,GAAKD,EAAG,KAAOE,EAAG,GAAKF,EAAG,GAC7E,CACA,SAASV,EAASa,EAAQC,GACtB,OAAID,EAAO,KAAOC,EAAO,GACdD,EAAO,GAAKC,EAAO,GAEvBD,EAAO,GAAKC,EAAO,EAC9B,C,gOCnBA,MAEMC,EAAmBC,KAAKC,GAAK,EAE7BC,EAAiB,IAAIC,EAAA,EAAK,CAC9BC,MAAO,2BAEHC,EAAmB,IAAIC,EAAA,EAAO,CAClCF,MAAO,sBACPG,MAAO,MAEHC,EAAkB,IAAIL,EAAA,EAAK,CAC/BC,MAAO,6BAEHK,EAAkB,IAAIN,EAAA,EAAK,CAC/BC,MAAO,2BAEHM,EAAW,IAAIP,EAAA,EAAK,CACxBC,MAAO,SAEHO,EAAa,IAAIL,EAAA,EAAO,CAC5BF,MAAO,qBACPG,MAAO,IAEHK,EAAc,IAAIC,EAAA,EAAY,CAClCC,OAAQ,GACRC,KAAMN,IAEFO,EAAc,IAAIH,EAAA,EAAY,CAClCC,OAAQ,GACRC,KAAMP,IAEFS,EAAW,IAAIC,EAAA,EAAK,CACxBC,IAAK,iCAEDC,EAAY,IAAIF,EAAA,EAAK,CACzBC,IAAK,yCAQP,SAASE,EAAmBC,GAC1B,OAAO,IAAIC,EAAA,GAAM,CACfC,SAAUF,EAAcG,cACxBC,MAAOJ,EAAcK,IAAI,YAAc,EAAIV,EAAWG,GAE1D,CAEA,IAAIQ,EAAcC,EAsEdC,EA/DJ,SAASC,EAAmBC,EAASC,GACnC,GAAID,IAAYJ,GAAgBK,IAAeJ,EAC7C,OAAO,KAET,MAAMK,EAAiBF,EAAQL,IAAI,YAC7BQ,EAAoBH,EAAQP,cAAcW,iBAChD,OAmCF,SAA8BC,EAAOC,EAAeL,GAGlD,IAAIM,EADFC,IAAmD,EAAIH,IACd,EAAVrC,KAAKC,IACtC,MAAMwC,EAAuB,EAAVzC,KAAKC,GAAUoC,EAC5BK,EAAM,GACZ,IAAIC,EAEJJ,EAAYvC,KAAK4C,IAAIL,EAAW,IAAMN,EAEtC,IAAK,IAAI3C,EAAI,EAAGA,EAAI+C,IAAS/C,EAE3BqD,EAAQ5C,EAAmBT,EAAImD,EAC/BC,EAAIG,KAAK,CACPP,EAAc,GAAKC,EAAYvC,KAAK8C,IAAIH,GACxCL,EAAc,GAAKC,EAAYvC,KAAK+C,IAAIJ,KAI5C,OAAOD,CACT,CAvDSM,CACLd,EAAehD,OACf8C,EAAQP,cAAcW,iBACtBH,GACAgB,QAAO,CAACC,EAAQC,EAAa7D,KAC7B,MAAMC,EAAQ,IAAI6D,EAAA,EAAMD,GAClBE,EAAO,IAAIC,EAAA,EAAW,CAACnB,EAAmBgB,IAehD,OAdAD,EAAOK,QACL,IAAIhC,EAAA,GAAM,CACRC,SAAU6B,EACVG,OAAQnD,KAGZ6C,EAAOL,KACLxB,EACE,IAAIoC,EAAA,EAAQ,IACPvB,EAAe5C,GAAGoE,gBACrBlC,SAAUjC,MAIT2D,CAAM,GACZ,GACL,CAwCA,SAASS,EAAiB3B,GACxB,GAAIA,IAAYF,EACd,OAAO,KAET,MACMnD,EADmBqD,EAAQL,IAAI,YACLiC,KAAKC,GACnCA,EAAQpC,cAAcW,mBAExB,OAAO,IAAIb,EAAA,GAAM,CACfC,SAAU,IAAIsC,EAAA,GAAQ,CAACpF,EAAwBC,KAC/CoC,KAAMb,EACNsD,OAAQnD,GAEZ,CAuBA,MAAM0D,EAAe,IAAI,IAAa,CACpCC,OAAQ,IAAIC,EAAA,EACZC,IAAK,mCAGDC,EAAgB,IAAIC,EAAA,EAAQ,CAChCC,aACE,2FACFC,SAAU,GACVC,OAAQR,IAIJS,EAAe,IAAIC,EAAA,EAAY,CACnCF,OAAQJ,EACRO,MAAOf,IAIHgB,EAAW,IAAIF,EAAA,EAAY,CAC/BF,OAAQJ,EACRO,MA1CF,SAAsBb,GACpB,MAAMe,EAAOf,EAAQlC,IAAI,YAAYzC,OACrC,OAAI0F,EAAO,EACF,CACL,IAAIrD,EAAA,GAAM,CACRG,MAAOV,IAET,IAAIO,EAAA,GAAM,CACRG,MAAOd,EACPiE,KAAM,IAAIC,EAAA,EAAK,CACbD,KAAMD,EAAKG,WACXhE,KAAML,EACN8C,OAAQ7C,OAMTU,EADiBwC,EAAQlC,IAAI,YAAY,GAElD,IA2BMqD,EAAiB,IAAIP,EAAA,EAAY,CACrCF,OAAQJ,EACRO,MAAO3C,IAGHkD,EAAS,IAAIC,EAAA,EAAU,CAC3BX,OAAQ,IAAIY,EAAA,EAAU,CACpBd,aACE,yEACFH,IAAK,sFAIHN,EAAM,IAAIwB,EAAA,EAAI,CAClBC,OAAQ,CAACJ,EAAQT,EAAcG,EAAUK,GACzCM,OAAQ,MACRC,KAAM,IAAIC,EAAA,GAAK,CACbC,OAAQ,CAAC,EAAG,GACZC,KAAM,EACNC,QAAS,GACTC,OAAQ,KACH,QAAW,CAAC,QAAS,cACrB,QAAW,CAAC,QAAS,UAE1BC,gBAAgB,MAIpBjC,EAAIkC,GAAG,eAAgBC,IACrBpB,EAASqB,YAAYD,EAAME,OAAOC,MAAMC,IAClCA,EAAS,KAAOrE,IAElBA,EAAeqE,EAAS,GACxB3B,EAAa4B,SAASzC,GAEtBC,EAAIyC,mBAAmB3B,MAAM4B,OAC3BxE,GAAgBA,EAAaH,IAAI,YAAYzC,OAAS,EAClD,UACA,GACR,GACA,IAGJ0E,EAAIkC,GAAG,SAAUC,IACfpB,EAASqB,YAAYD,EAAME,OAAOC,MAAMC,IACtC,GAAIA,EAASjH,OAAS,EAAG,CACvB,MAAMgD,EAAiBiE,EAAS,GAAGxE,IAAI,YACvC,GAAIO,EAAehD,OAAS,EAAG,CAE7B,MAAM0G,GAAS,UACf1D,EAAeqE,SAAS1C,IACtB,QAAO+B,EAAQ/B,EAAQpC,cAAc+E,eAEvC,MAAMjB,EAAO3B,EAAI6C,UACXxE,EAAa2B,EAAI6C,UAAUC,gBAE/BnB,EAAKoB,YAAcpB,EAAKqB,eACvB,QAAShB,GAAU3D,IAAc,QAAU2D,GAAU3D,GAGtDL,EAAeuE,EAAS,GACxBtE,EAAkBI,EAClB+C,EAAeoB,SAASrE,IAGxBwD,EAAKsB,IAAIjB,EAAQ,CAACkB,SAAU,IAAKC,QAAS,CAAC,GAAI,GAAI,GAAI,KAE3D,CACF,IACA,G","sources":["webpack:///../node_modules/monotone-chain-convex-hull/lib-esm/index.js","webpack:///./clusters-dynamic.js"],"sourcesContent":["/**\n * Computes the convex hull of a binary image using Andrew's Monotone Chain Algorithm\n * http://www.algorithmist.com/index.php/Monotone_Chain_Convex_Hull\n *\n * @param points - An array of points.\n * @param options - MCCH Algorithm options.\n * @return Coordinates of the convex hull in clockwise order\n */\nexport default function monotoneChainConvexHull(points, options = {}) {\n    const { sorted } = options;\n    if (!sorted) {\n        points = points.slice().sort(byXThenY);\n    }\n    const n = points.length;\n    const result = new Array(n * 2);\n    let k = 0;\n    for (let i = 0; i < n; i++) {\n        const point = points[i];\n        while (k >= 2 && cw(result[k - 2], result[k - 1], point) <= 0) {\n            k--;\n        }\n        result[k++] = point;\n    }\n    const t = k + 1;\n    for (let i = n - 2; i >= 0; i--) {\n        const point = points[i];\n        while (k >= t && cw(result[k - 2], result[k - 1], point) <= 0) {\n            k--;\n        }\n        result[k++] = point;\n    }\n    return result.slice(0, k - 1);\n}\nfunction cw(p1, p2, p3) {\n    return (p2[1] - p1[1]) * (p3[0] - p1[0]) - (p2[0] - p1[0]) * (p3[1] - p1[1]);\n}\nfunction byXThenY(point1, point2) {\n    if (point1[0] === point2[0]) {\n        return point1[1] - point2[1];\n    }\n    return point1[0] - point2[0];\n}\n//# sourceMappingURL=index.js.map","import monotoneChainConvexHull from 'monotone-chain-convex-hull';\nimport Feature from '../src/ol/Feature.js';\nimport Map from '../src/ol/Map.js';\nimport View from '../src/ol/View.js';\nimport {createEmpty, extend, getHeight, getWidth} from '../src/ol/extent.js';\nimport GeoJSON from '../src/ol/format/GeoJSON.js';\nimport LineString from '../src/ol/geom/LineString.js';\nimport Point from '../src/ol/geom/Point.js';\nimport Polygon from '../src/ol/geom/Polygon.js';\nimport TileLayer from '../src/ol/layer/Tile.js';\nimport VectorLayer from '../src/ol/layer/Vector.js';\nimport {fromLonLat} from '../src/ol/proj.js';\nimport Cluster from '../src/ol/source/Cluster.js';\nimport ImageTile from '../src/ol/source/ImageTile.js';\nimport VectorSource from '../src/ol/source/Vector.js';\nimport CircleStyle from '../src/ol/style/Circle.js';\nimport Fill from '../src/ol/style/Fill.js';\nimport Icon from '../src/ol/style/Icon.js';\nimport Stroke from '../src/ol/style/Stroke.js';\nimport Style from '../src/ol/style/Style.js';\nimport Text from '../src/ol/style/Text.js';\n\nconst circleDistanceMultiplier = 1;\nconst circleFootSeparation = 28;\nconst circleStartAngle = Math.PI / 2;\n\nconst convexHullFill = new Fill({\n  color: 'rgba(255, 153, 0, 0.4)',\n});\nconst convexHullStroke = new Stroke({\n  color: 'rgba(204, 85, 0, 1)',\n  width: 1.5,\n});\nconst outerCircleFill = new Fill({\n  color: 'rgba(255, 153, 102, 0.3)',\n});\nconst innerCircleFill = new Fill({\n  color: 'rgba(255, 165, 0, 0.7)',\n});\nconst textFill = new Fill({\n  color: '#fff',\n});\nconst textStroke = new Stroke({\n  color: 'rgba(0, 0, 0, 0.6)',\n  width: 3,\n});\nconst innerCircle = new CircleStyle({\n  radius: 14,\n  fill: innerCircleFill,\n});\nconst outerCircle = new CircleStyle({\n  radius: 20,\n  fill: outerCircleFill,\n});\nconst darkIcon = new Icon({\n  src: 'data/icons/emoticon-cool.svg',\n});\nconst lightIcon = new Icon({\n  src: 'data/icons/emoticon-cool-outline.svg',\n});\n\n/**\n * Single feature style, users for clusters with 1 feature and cluster circles.\n * @param {Feature} clusterMember A feature from a cluster.\n * @return {Style} An icon style for the cluster member's location.\n */\nfunction clusterMemberStyle(clusterMember) {\n  return new Style({\n    geometry: clusterMember.getGeometry(),\n    image: clusterMember.get('LEISTUNG') > 5 ? darkIcon : lightIcon,\n  });\n}\n\nlet clickFeature, clickResolution;\n/**\n * Style for clusters with features that are too close to each other, activated on click.\n * @param {Feature} cluster A cluster with overlapping members.\n * @param {number} resolution The current view resolution.\n * @return {Array<Style>|null} A style to render an expanded view of the cluster members.\n */\nfunction clusterCircleStyle(cluster, resolution) {\n  if (cluster !== clickFeature || resolution !== clickResolution) {\n    return null;\n  }\n  const clusterMembers = cluster.get('features');\n  const centerCoordinates = cluster.getGeometry().getCoordinates();\n  return generatePointsCircle(\n    clusterMembers.length,\n    cluster.getGeometry().getCoordinates(),\n    resolution,\n  ).reduce((styles, coordinates, i) => {\n    const point = new Point(coordinates);\n    const line = new LineString([centerCoordinates, coordinates]);\n    styles.unshift(\n      new Style({\n        geometry: line,\n        stroke: convexHullStroke,\n      }),\n    );\n    styles.push(\n      clusterMemberStyle(\n        new Feature({\n          ...clusterMembers[i].getProperties(),\n          geometry: point,\n        }),\n      ),\n    );\n    return styles;\n  }, []);\n}\n\n/**\n * From\n * https://github.com/Leaflet/Leaflet.markercluster/blob/31360f2/src/MarkerCluster.Spiderfier.js#L55-L72\n * Arranges points in a circle around the cluster center, with a line pointing from the center to\n * each point.\n * @param {number} count Number of cluster members.\n * @param {Array<number>} clusterCenter Center coordinate of the cluster.\n * @param {number} resolution Current view resolution.\n * @return {Array<Array<number>>} An array of coordinates representing the cluster members.\n */\nfunction generatePointsCircle(count, clusterCenter, resolution) {\n  const circumference =\n    circleDistanceMultiplier * circleFootSeparation * (2 + count);\n  let legLength = circumference / (Math.PI * 2); //radius from circumference\n  const angleStep = (Math.PI * 2) / count;\n  const res = [];\n  let angle;\n\n  legLength = Math.max(legLength, 35) * resolution; // Minimum distance to get outside the cluster icon.\n\n  for (let i = 0; i < count; ++i) {\n    // Clockwise, like spiral.\n    angle = circleStartAngle + i * angleStep;\n    res.push([\n      clusterCenter[0] + legLength * Math.cos(angle),\n      clusterCenter[1] + legLength * Math.sin(angle),\n    ]);\n  }\n\n  return res;\n}\n\nlet hoverFeature;\n/**\n * Style for convex hulls of clusters, activated on hover.\n * @param {Feature} cluster The cluster feature.\n * @return {Style|null} Polygon style for the convex hull of the cluster.\n */\nfunction clusterHullStyle(cluster) {\n  if (cluster !== hoverFeature) {\n    return null;\n  }\n  const originalFeatures = cluster.get('features');\n  const points = originalFeatures.map((feature) =>\n    feature.getGeometry().getCoordinates(),\n  );\n  return new Style({\n    geometry: new Polygon([monotoneChainConvexHull(points)]),\n    fill: convexHullFill,\n    stroke: convexHullStroke,\n  });\n}\n\nfunction clusterStyle(feature) {\n  const size = feature.get('features').length;\n  if (size > 1) {\n    return [\n      new Style({\n        image: outerCircle,\n      }),\n      new Style({\n        image: innerCircle,\n        text: new Text({\n          text: size.toString(),\n          fill: textFill,\n          stroke: textStroke,\n        }),\n      }),\n    ];\n  }\n  const originalFeature = feature.get('features')[0];\n  return clusterMemberStyle(originalFeature);\n}\n\nconst vectorSource = new VectorSource({\n  format: new GeoJSON(),\n  url: 'data/geojson/photovoltaic.json',\n});\n\nconst clusterSource = new Cluster({\n  attributions:\n    'Data: <a href=\"https://www.data.gv.at/auftritte/?organisation=stadt-wien\">Stadt Wien</a>',\n  distance: 35,\n  source: vectorSource,\n});\n\n// Layer displaying the convex hull of the hovered cluster.\nconst clusterHulls = new VectorLayer({\n  source: clusterSource,\n  style: clusterHullStyle,\n});\n\n// Layer displaying the clusters and individual features.\nconst clusters = new VectorLayer({\n  source: clusterSource,\n  style: clusterStyle,\n});\n\n// Layer displaying the expanded view of overlapping cluster members.\nconst clusterCircles = new VectorLayer({\n  source: clusterSource,\n  style: clusterCircleStyle,\n});\n\nconst raster = new TileLayer({\n  source: new ImageTile({\n    attributions:\n      'Base map: <a target=\"_blank\" href=\"https://basemap.at/\">basemap.at</a>',\n    url: 'https://maps{1-4}.wien.gv.at/basemap/bmapgrau/normal/google3857/{z}/{y}/{x}.png',\n  }),\n});\n\nconst map = new Map({\n  layers: [raster, clusterHulls, clusters, clusterCircles],\n  target: 'map',\n  view: new View({\n    center: [0, 0],\n    zoom: 2,\n    maxZoom: 19,\n    extent: [\n      ...fromLonLat([16.1793, 48.1124]),\n      ...fromLonLat([16.5559, 48.313]),\n    ],\n    showFullExtent: true,\n  }),\n});\n\nmap.on('pointermove', (event) => {\n  clusters.getFeatures(event.pixel).then((features) => {\n    if (features[0] !== hoverFeature) {\n      // Display the convex hull on hover.\n      hoverFeature = features[0];\n      clusterHulls.setStyle(clusterHullStyle);\n      // Change the cursor style to indicate that the cluster is clickable.\n      map.getTargetElement().style.cursor =\n        hoverFeature && hoverFeature.get('features').length > 1\n          ? 'pointer'\n          : '';\n    }\n  });\n});\n\nmap.on('click', (event) => {\n  clusters.getFeatures(event.pixel).then((features) => {\n    if (features.length > 0) {\n      const clusterMembers = features[0].get('features');\n      if (clusterMembers.length > 1) {\n        // Calculate the extent of the cluster members.\n        const extent = createEmpty();\n        clusterMembers.forEach((feature) =>\n          extend(extent, feature.getGeometry().getExtent()),\n        );\n        const view = map.getView();\n        const resolution = map.getView().getResolution();\n        if (\n          view.getZoom() === view.getMaxZoom() ||\n          (getWidth(extent) < resolution && getHeight(extent) < resolution)\n        ) {\n          // Show an expanded view of the cluster members.\n          clickFeature = features[0];\n          clickResolution = resolution;\n          clusterCircles.setStyle(clusterCircleStyle);\n        } else {\n          // Zoom to the extent of the cluster members.\n          view.fit(extent, {duration: 500, padding: [50, 50, 50, 50]});\n        }\n      }\n    }\n  });\n});\n"],"names":["monotoneChainConvexHull","points","options","sorted","slice","sort","byXThenY","n","length","result","Array","k","i","point","cw","t","p1","p2","p3","point1","point2","circleStartAngle","Math","PI","convexHullFill","Fill","color","convexHullStroke","Stroke","width","outerCircleFill","innerCircleFill","textFill","textStroke","innerCircle","Circle","radius","fill","outerCircle","darkIcon","Icon","src","lightIcon","clusterMemberStyle","clusterMember","Style","geometry","getGeometry","image","get","clickFeature","clickResolution","hoverFeature","clusterCircleStyle","cluster","resolution","clusterMembers","centerCoordinates","getCoordinates","count","clusterCenter","legLength","circleDistanceMultiplier","angleStep","res","angle","max","push","cos","sin","generatePointsCircle","reduce","styles","coordinates","Point","line","LineString","unshift","stroke","Feature","getProperties","clusterHullStyle","map","feature","Polygon","vectorSource","format","GeoJSON","url","clusterSource","Cluster","attributions","distance","source","clusterHulls","Vector","style","clusters","size","text","Text","toString","clusterCircles","raster","Tile","ImageTile","Map","layers","target","view","View","center","zoom","maxZoom","extent","showFullExtent","on","event","getFeatures","pixel","then","features","setStyle","getTargetElement","cursor","forEach","getExtent","getView","getResolution","getZoom","getMaxZoom","fit","duration","padding"],"sourceRoot":""}