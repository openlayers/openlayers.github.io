{"version":3,"file":"turf.js","mappings":"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","sources":["webpack:///../node_modules/@turf/helpers/dist/esm/index.js","webpack:///../node_modules/@turf/invariant/dist/esm/index.js","webpack:///../node_modules/@turf/bearing/dist/esm/index.js","webpack:///../node_modules/@turf/destination/dist/esm/index.js","webpack:///../node_modules/@turf/distance/dist/esm/index.js","webpack:///../node_modules/@turf/along/dist/esm/index.js","webpack:///../node_modules/@turf/meta/dist/esm/index.js","webpack:///../node_modules/@turf/length/dist/esm/index.js","webpack:///./turf.js"],"sourcesContent":["// index.ts\nvar earthRadius = 63710088e-1;\nvar factors = {\n  centimeters: earthRadius * 100,\n  centimetres: earthRadius * 100,\n  degrees: 360 / (2 * Math.PI),\n  feet: earthRadius * 3.28084,\n  inches: earthRadius * 39.37,\n  kilometers: earthRadius / 1e3,\n  kilometres: earthRadius / 1e3,\n  meters: earthRadius,\n  metres: earthRadius,\n  miles: earthRadius / 1609.344,\n  millimeters: earthRadius * 1e3,\n  millimetres: earthRadius * 1e3,\n  nauticalmiles: earthRadius / 1852,\n  radians: 1,\n  yards: earthRadius * 1.0936\n};\nvar areaFactors = {\n  acres: 247105e-9,\n  centimeters: 1e4,\n  centimetres: 1e4,\n  feet: 10.763910417,\n  hectares: 1e-4,\n  inches: 1550.003100006,\n  kilometers: 1e-6,\n  kilometres: 1e-6,\n  meters: 1,\n  metres: 1,\n  miles: 386e-9,\n  nauticalmiles: 29155334959812285e-23,\n  millimeters: 1e6,\n  millimetres: 1e6,\n  yards: 1.195990046\n};\nfunction feature(geom, properties, options = {}) {\n  const feat = { type: \"Feature\" };\n  if (options.id === 0 || options.id) {\n    feat.id = options.id;\n  }\n  if (options.bbox) {\n    feat.bbox = options.bbox;\n  }\n  feat.properties = properties || {};\n  feat.geometry = geom;\n  return feat;\n}\nfunction geometry(type, coordinates, _options = {}) {\n  switch (type) {\n    case \"Point\":\n      return point(coordinates).geometry;\n    case \"LineString\":\n      return lineString(coordinates).geometry;\n    case \"Polygon\":\n      return polygon(coordinates).geometry;\n    case \"MultiPoint\":\n      return multiPoint(coordinates).geometry;\n    case \"MultiLineString\":\n      return multiLineString(coordinates).geometry;\n    case \"MultiPolygon\":\n      return multiPolygon(coordinates).geometry;\n    default:\n      throw new Error(type + \" is invalid\");\n  }\n}\nfunction point(coordinates, properties, options = {}) {\n  if (!coordinates) {\n    throw new Error(\"coordinates is required\");\n  }\n  if (!Array.isArray(coordinates)) {\n    throw new Error(\"coordinates must be an Array\");\n  }\n  if (coordinates.length < 2) {\n    throw new Error(\"coordinates must be at least 2 numbers long\");\n  }\n  if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) {\n    throw new Error(\"coordinates must contain numbers\");\n  }\n  const geom = {\n    type: \"Point\",\n    coordinates\n  };\n  return feature(geom, properties, options);\n}\nfunction points(coordinates, properties, options = {}) {\n  return featureCollection(\n    coordinates.map((coords) => {\n      return point(coords, properties);\n    }),\n    options\n  );\n}\nfunction polygon(coordinates, properties, options = {}) {\n  for (const ring of coordinates) {\n    if (ring.length < 4) {\n      throw new Error(\n        \"Each LinearRing of a Polygon must have 4 or more Positions.\"\n      );\n    }\n    if (ring[ring.length - 1].length !== ring[0].length) {\n      throw new Error(\"First and last Position are not equivalent.\");\n    }\n    for (let j = 0; j < ring[ring.length - 1].length; j++) {\n      if (ring[ring.length - 1][j] !== ring[0][j]) {\n        throw new Error(\"First and last Position are not equivalent.\");\n      }\n    }\n  }\n  const geom = {\n    type: \"Polygon\",\n    coordinates\n  };\n  return feature(geom, properties, options);\n}\nfunction polygons(coordinates, properties, options = {}) {\n  return featureCollection(\n    coordinates.map((coords) => {\n      return polygon(coords, properties);\n    }),\n    options\n  );\n}\nfunction lineString(coordinates, properties, options = {}) {\n  if (coordinates.length < 2) {\n    throw new Error(\"coordinates must be an array of two or more positions\");\n  }\n  const geom = {\n    type: \"LineString\",\n    coordinates\n  };\n  return feature(geom, properties, options);\n}\nfunction lineStrings(coordinates, properties, options = {}) {\n  return featureCollection(\n    coordinates.map((coords) => {\n      return lineString(coords, properties);\n    }),\n    options\n  );\n}\nfunction featureCollection(features, options = {}) {\n  const fc = { type: \"FeatureCollection\" };\n  if (options.id) {\n    fc.id = options.id;\n  }\n  if (options.bbox) {\n    fc.bbox = options.bbox;\n  }\n  fc.features = features;\n  return fc;\n}\nfunction multiLineString(coordinates, properties, options = {}) {\n  const geom = {\n    type: \"MultiLineString\",\n    coordinates\n  };\n  return feature(geom, properties, options);\n}\nfunction multiPoint(coordinates, properties, options = {}) {\n  const geom = {\n    type: \"MultiPoint\",\n    coordinates\n  };\n  return feature(geom, properties, options);\n}\nfunction multiPolygon(coordinates, properties, options = {}) {\n  const geom = {\n    type: \"MultiPolygon\",\n    coordinates\n  };\n  return feature(geom, properties, options);\n}\nfunction geometryCollection(geometries, properties, options = {}) {\n  const geom = {\n    type: \"GeometryCollection\",\n    geometries\n  };\n  return feature(geom, properties, options);\n}\nfunction round(num, precision = 0) {\n  if (precision && !(precision >= 0)) {\n    throw new Error(\"precision must be a positive number\");\n  }\n  const multiplier = Math.pow(10, precision || 0);\n  return Math.round(num * multiplier) / multiplier;\n}\nfunction radiansToLength(radians, units = \"kilometers\") {\n  const factor = factors[units];\n  if (!factor) {\n    throw new Error(units + \" units is invalid\");\n  }\n  return radians * factor;\n}\nfunction lengthToRadians(distance, units = \"kilometers\") {\n  const factor = factors[units];\n  if (!factor) {\n    throw new Error(units + \" units is invalid\");\n  }\n  return distance / factor;\n}\nfunction lengthToDegrees(distance, units) {\n  return radiansToDegrees(lengthToRadians(distance, units));\n}\nfunction bearingToAzimuth(bearing) {\n  let angle = bearing % 360;\n  if (angle < 0) {\n    angle += 360;\n  }\n  return angle;\n}\nfunction azimuthToBearing(angle) {\n  angle = angle % 360;\n  if (angle > 180) {\n    return angle - 360;\n  } else if (angle < -180) {\n    return angle + 360;\n  }\n  return angle;\n}\nfunction radiansToDegrees(radians) {\n  const normalisedRadians = radians % (2 * Math.PI);\n  return normalisedRadians * 180 / Math.PI;\n}\nfunction degreesToRadians(degrees) {\n  const normalisedDegrees = degrees % 360;\n  return normalisedDegrees * Math.PI / 180;\n}\nfunction convertLength(length, originalUnit = \"kilometers\", finalUnit = \"kilometers\") {\n  if (!(length >= 0)) {\n    throw new Error(\"length must be a positive number\");\n  }\n  return radiansToLength(lengthToRadians(length, originalUnit), finalUnit);\n}\nfunction convertArea(area, originalUnit = \"meters\", finalUnit = \"kilometers\") {\n  if (!(area >= 0)) {\n    throw new Error(\"area must be a positive number\");\n  }\n  const startFactor = areaFactors[originalUnit];\n  if (!startFactor) {\n    throw new Error(\"invalid original units\");\n  }\n  const finalFactor = areaFactors[finalUnit];\n  if (!finalFactor) {\n    throw new Error(\"invalid final units\");\n  }\n  return area / startFactor * finalFactor;\n}\nfunction isNumber(num) {\n  return !isNaN(num) && num !== null && !Array.isArray(num);\n}\nfunction isObject(input) {\n  return input !== null && typeof input === \"object\" && !Array.isArray(input);\n}\nfunction validateBBox(bbox) {\n  if (!bbox) {\n    throw new Error(\"bbox is required\");\n  }\n  if (!Array.isArray(bbox)) {\n    throw new Error(\"bbox must be an Array\");\n  }\n  if (bbox.length !== 4 && bbox.length !== 6) {\n    throw new Error(\"bbox must be an Array of 4 or 6 numbers\");\n  }\n  bbox.forEach((num) => {\n    if (!isNumber(num)) {\n      throw new Error(\"bbox must only contain numbers\");\n    }\n  });\n}\nfunction validateId(id) {\n  if (!id) {\n    throw new Error(\"id is required\");\n  }\n  if ([\"string\", \"number\"].indexOf(typeof id) === -1) {\n    throw new Error(\"id must be a number or a string\");\n  }\n}\nexport {\n  areaFactors,\n  azimuthToBearing,\n  bearingToAzimuth,\n  convertArea,\n  convertLength,\n  degreesToRadians,\n  earthRadius,\n  factors,\n  feature,\n  featureCollection,\n  geometry,\n  geometryCollection,\n  isNumber,\n  isObject,\n  lengthToDegrees,\n  lengthToRadians,\n  lineString,\n  lineStrings,\n  multiLineString,\n  multiPoint,\n  multiPolygon,\n  point,\n  points,\n  polygon,\n  polygons,\n  radiansToDegrees,\n  radiansToLength,\n  round,\n  validateBBox,\n  validateId\n};\n//# sourceMappingURL=index.js.map","// index.ts\nimport { isNumber } from \"@turf/helpers\";\nfunction getCoord(coord) {\n  if (!coord) {\n    throw new Error(\"coord is required\");\n  }\n  if (!Array.isArray(coord)) {\n    if (coord.type === \"Feature\" && coord.geometry !== null && coord.geometry.type === \"Point\") {\n      return [...coord.geometry.coordinates];\n    }\n    if (coord.type === \"Point\") {\n      return [...coord.coordinates];\n    }\n  }\n  if (Array.isArray(coord) && coord.length >= 2 && !Array.isArray(coord[0]) && !Array.isArray(coord[1])) {\n    return [...coord];\n  }\n  throw new Error(\"coord must be GeoJSON Point or an Array of numbers\");\n}\nfunction getCoords(coords) {\n  if (Array.isArray(coords)) {\n    return coords;\n  }\n  if (coords.type === \"Feature\") {\n    if (coords.geometry !== null) {\n      return coords.geometry.coordinates;\n    }\n  } else {\n    if (coords.coordinates) {\n      return coords.coordinates;\n    }\n  }\n  throw new Error(\n    \"coords must be GeoJSON Feature, Geometry Object or an Array\"\n  );\n}\nfunction containsNumber(coordinates) {\n  if (coordinates.length > 1 && isNumber(coordinates[0]) && isNumber(coordinates[1])) {\n    return true;\n  }\n  if (Array.isArray(coordinates[0]) && coordinates[0].length) {\n    return containsNumber(coordinates[0]);\n  }\n  throw new Error(\"coordinates must only contain numbers\");\n}\nfunction geojsonType(value, type, name) {\n  if (!type || !name) {\n    throw new Error(\"type and name required\");\n  }\n  if (!value || value.type !== type) {\n    throw new Error(\n      \"Invalid input to \" + name + \": must be a \" + type + \", given \" + value.type\n    );\n  }\n}\nfunction featureOf(feature, type, name) {\n  if (!feature) {\n    throw new Error(\"No feature passed\");\n  }\n  if (!name) {\n    throw new Error(\".featureOf() requires a name\");\n  }\n  if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\n    throw new Error(\n      \"Invalid input to \" + name + \", Feature with geometry required\"\n    );\n  }\n  if (!feature.geometry || feature.geometry.type !== type) {\n    throw new Error(\n      \"Invalid input to \" + name + \": must be a \" + type + \", given \" + feature.geometry.type\n    );\n  }\n}\nfunction collectionOf(featureCollection, type, name) {\n  if (!featureCollection) {\n    throw new Error(\"No featureCollection passed\");\n  }\n  if (!name) {\n    throw new Error(\".collectionOf() requires a name\");\n  }\n  if (!featureCollection || featureCollection.type !== \"FeatureCollection\") {\n    throw new Error(\n      \"Invalid input to \" + name + \", FeatureCollection required\"\n    );\n  }\n  for (const feature of featureCollection.features) {\n    if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\n      throw new Error(\n        \"Invalid input to \" + name + \", Feature with geometry required\"\n      );\n    }\n    if (!feature.geometry || feature.geometry.type !== type) {\n      throw new Error(\n        \"Invalid input to \" + name + \": must be a \" + type + \", given \" + feature.geometry.type\n      );\n    }\n  }\n}\nfunction getGeom(geojson) {\n  if (geojson.type === \"Feature\") {\n    return geojson.geometry;\n  }\n  return geojson;\n}\nfunction getType(geojson, _name) {\n  if (geojson.type === \"FeatureCollection\") {\n    return \"FeatureCollection\";\n  }\n  if (geojson.type === \"GeometryCollection\") {\n    return \"GeometryCollection\";\n  }\n  if (geojson.type === \"Feature\" && geojson.geometry !== null) {\n    return geojson.geometry.type;\n  }\n  return geojson.type;\n}\nexport {\n  collectionOf,\n  containsNumber,\n  featureOf,\n  geojsonType,\n  getCoord,\n  getCoords,\n  getGeom,\n  getType\n};\n//# sourceMappingURL=index.js.map","// index.ts\nimport { degreesToRadians, radiansToDegrees } from \"@turf/helpers\";\nimport { getCoord } from \"@turf/invariant\";\nfunction bearing(start, end, options = {}) {\n  if (options.final === true) {\n    return calculateFinalBearing(start, end);\n  }\n  const coordinates1 = getCoord(start);\n  const coordinates2 = getCoord(end);\n  const lon1 = degreesToRadians(coordinates1[0]);\n  const lon2 = degreesToRadians(coordinates2[0]);\n  const lat1 = degreesToRadians(coordinates1[1]);\n  const lat2 = degreesToRadians(coordinates2[1]);\n  const a = Math.sin(lon2 - lon1) * Math.cos(lat2);\n  const b = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);\n  return radiansToDegrees(Math.atan2(a, b));\n}\nfunction calculateFinalBearing(start, end) {\n  let bear = bearing(end, start);\n  bear = (bear + 180) % 360;\n  return bear;\n}\nvar turf_bearing_default = bearing;\nexport {\n  bearing,\n  turf_bearing_default as default\n};\n//# sourceMappingURL=index.js.map","// index.ts\nimport {\n  degreesToRadians,\n  lengthToRadians,\n  point,\n  radiansToDegrees\n} from \"@turf/helpers\";\nimport { getCoord } from \"@turf/invariant\";\nfunction destination(origin, distance, bearing, options = {}) {\n  const coordinates1 = getCoord(origin);\n  const longitude1 = degreesToRadians(coordinates1[0]);\n  const latitude1 = degreesToRadians(coordinates1[1]);\n  const bearingRad = degreesToRadians(bearing);\n  const radians = lengthToRadians(distance, options.units);\n  const latitude2 = Math.asin(\n    Math.sin(latitude1) * Math.cos(radians) + Math.cos(latitude1) * Math.sin(radians) * Math.cos(bearingRad)\n  );\n  const longitude2 = longitude1 + Math.atan2(\n    Math.sin(bearingRad) * Math.sin(radians) * Math.cos(latitude1),\n    Math.cos(radians) - Math.sin(latitude1) * Math.sin(latitude2)\n  );\n  const lng = radiansToDegrees(longitude2);\n  const lat = radiansToDegrees(latitude2);\n  return point([lng, lat], options.properties);\n}\nvar turf_destination_default = destination;\nexport {\n  turf_destination_default as default,\n  destination\n};\n//# sourceMappingURL=index.js.map","// index.ts\nimport { getCoord } from \"@turf/invariant\";\nimport { radiansToLength, degreesToRadians } from \"@turf/helpers\";\nfunction distance(from, to, options = {}) {\n  var coordinates1 = getCoord(from);\n  var coordinates2 = getCoord(to);\n  var dLat = degreesToRadians(coordinates2[1] - coordinates1[1]);\n  var dLon = degreesToRadians(coordinates2[0] - coordinates1[0]);\n  var lat1 = degreesToRadians(coordinates1[1]);\n  var lat2 = degreesToRadians(coordinates2[1]);\n  var a = Math.pow(Math.sin(dLat / 2), 2) + Math.pow(Math.sin(dLon / 2), 2) * Math.cos(lat1) * Math.cos(lat2);\n  return radiansToLength(\n    2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)),\n    options.units\n  );\n}\nvar turf_distance_default = distance;\nexport {\n  turf_distance_default as default,\n  distance\n};\n//# sourceMappingURL=index.js.map","// index.ts\nimport { bearing } from \"@turf/bearing\";\nimport { destination } from \"@turf/destination\";\nimport { distance as measureDistance } from \"@turf/distance\";\nimport { point } from \"@turf/helpers\";\nimport { getGeom } from \"@turf/invariant\";\nfunction along(line, distance, options = {}) {\n  const geom = getGeom(line);\n  const coords = geom.coordinates;\n  let travelled = 0;\n  for (let i = 0; i < coords.length; i++) {\n    if (distance >= travelled && i === coords.length - 1) {\n      break;\n    } else if (travelled >= distance) {\n      const overshot = distance - travelled;\n      if (!overshot) {\n        return point(coords[i]);\n      } else {\n        const direction = bearing(coords[i], coords[i - 1]) - 180;\n        const interpolated = destination(\n          coords[i],\n          overshot,\n          direction,\n          options\n        );\n        return interpolated;\n      }\n    } else {\n      travelled += measureDistance(coords[i], coords[i + 1], options);\n    }\n  }\n  return point(coords[coords.length - 1]);\n}\nvar turf_along_default = along;\nexport {\n  along,\n  turf_along_default as default\n};\n//# sourceMappingURL=index.js.map","// index.js\nimport { feature, point, lineString, isObject } from \"@turf/helpers\";\nfunction coordEach(geojson, callback, excludeWrapCoord) {\n  if (geojson === null) return;\n  var j, k, l, geometry, stopG, coords, geometryMaybeCollection, wrapShrink = 0, coordIndex = 0, isGeometryCollection, type = geojson.type, isFeatureCollection = type === \"FeatureCollection\", isFeature = type === \"Feature\", stop = isFeatureCollection ? geojson.features.length : 1;\n  for (var featureIndex = 0; featureIndex < stop; featureIndex++) {\n    geometryMaybeCollection = isFeatureCollection ? geojson.features[featureIndex].geometry : isFeature ? geojson.geometry : geojson;\n    isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === \"GeometryCollection\" : false;\n    stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n    for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {\n      var multiFeatureIndex = 0;\n      var geometryIndex = 0;\n      geometry = isGeometryCollection ? geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;\n      if (geometry === null) continue;\n      coords = geometry.coordinates;\n      var geomType = geometry.type;\n      wrapShrink = excludeWrapCoord && (geomType === \"Polygon\" || geomType === \"MultiPolygon\") ? 1 : 0;\n      switch (geomType) {\n        case null:\n          break;\n        case \"Point\":\n          if (callback(\n            coords,\n            coordIndex,\n            featureIndex,\n            multiFeatureIndex,\n            geometryIndex\n          ) === false)\n            return false;\n          coordIndex++;\n          multiFeatureIndex++;\n          break;\n        case \"LineString\":\n        case \"MultiPoint\":\n          for (j = 0; j < coords.length; j++) {\n            if (callback(\n              coords[j],\n              coordIndex,\n              featureIndex,\n              multiFeatureIndex,\n              geometryIndex\n            ) === false)\n              return false;\n            coordIndex++;\n            if (geomType === \"MultiPoint\") multiFeatureIndex++;\n          }\n          if (geomType === \"LineString\") multiFeatureIndex++;\n          break;\n        case \"Polygon\":\n        case \"MultiLineString\":\n          for (j = 0; j < coords.length; j++) {\n            for (k = 0; k < coords[j].length - wrapShrink; k++) {\n              if (callback(\n                coords[j][k],\n                coordIndex,\n                featureIndex,\n                multiFeatureIndex,\n                geometryIndex\n              ) === false)\n                return false;\n              coordIndex++;\n            }\n            if (geomType === \"MultiLineString\") multiFeatureIndex++;\n            if (geomType === \"Polygon\") geometryIndex++;\n          }\n          if (geomType === \"Polygon\") multiFeatureIndex++;\n          break;\n        case \"MultiPolygon\":\n          for (j = 0; j < coords.length; j++) {\n            geometryIndex = 0;\n            for (k = 0; k < coords[j].length; k++) {\n              for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                if (callback(\n                  coords[j][k][l],\n                  coordIndex,\n                  featureIndex,\n                  multiFeatureIndex,\n                  geometryIndex\n                ) === false)\n                  return false;\n                coordIndex++;\n              }\n              geometryIndex++;\n            }\n            multiFeatureIndex++;\n          }\n          break;\n        case \"GeometryCollection\":\n          for (j = 0; j < geometry.geometries.length; j++)\n            if (coordEach(geometry.geometries[j], callback, excludeWrapCoord) === false)\n              return false;\n          break;\n        default:\n          throw new Error(\"Unknown Geometry Type\");\n      }\n    }\n  }\n}\nfunction coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\n  var previousValue = initialValue;\n  coordEach(\n    geojson,\n    function(currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n      if (coordIndex === 0 && initialValue === void 0)\n        previousValue = currentCoord;\n      else\n        previousValue = callback(\n          previousValue,\n          currentCoord,\n          coordIndex,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex\n        );\n    },\n    excludeWrapCoord\n  );\n  return previousValue;\n}\nfunction propEach(geojson, callback) {\n  var i;\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      for (i = 0; i < geojson.features.length; i++) {\n        if (callback(geojson.features[i].properties, i) === false) break;\n      }\n      break;\n    case \"Feature\":\n      callback(geojson.properties, 0);\n      break;\n  }\n}\nfunction propReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  propEach(geojson, function(currentProperties, featureIndex) {\n    if (featureIndex === 0 && initialValue === void 0)\n      previousValue = currentProperties;\n    else\n      previousValue = callback(previousValue, currentProperties, featureIndex);\n  });\n  return previousValue;\n}\nfunction featureEach(geojson, callback) {\n  if (geojson.type === \"Feature\") {\n    callback(geojson, 0);\n  } else if (geojson.type === \"FeatureCollection\") {\n    for (var i = 0; i < geojson.features.length; i++) {\n      if (callback(geojson.features[i], i) === false) break;\n    }\n  }\n}\nfunction featureReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  featureEach(geojson, function(currentFeature, featureIndex) {\n    if (featureIndex === 0 && initialValue === void 0)\n      previousValue = currentFeature;\n    else previousValue = callback(previousValue, currentFeature, featureIndex);\n  });\n  return previousValue;\n}\nfunction coordAll(geojson) {\n  var coords = [];\n  coordEach(geojson, function(coord) {\n    coords.push(coord);\n  });\n  return coords;\n}\nfunction geomEach(geojson, callback) {\n  var i, j, g, geometry, stopG, geometryMaybeCollection, isGeometryCollection, featureProperties, featureBBox, featureId, featureIndex = 0, isFeatureCollection = geojson.type === \"FeatureCollection\", isFeature = geojson.type === \"Feature\", stop = isFeatureCollection ? geojson.features.length : 1;\n  for (i = 0; i < stop; i++) {\n    geometryMaybeCollection = isFeatureCollection ? geojson.features[i].geometry : isFeature ? geojson.geometry : geojson;\n    featureProperties = isFeatureCollection ? geojson.features[i].properties : isFeature ? geojson.properties : {};\n    featureBBox = isFeatureCollection ? geojson.features[i].bbox : isFeature ? geojson.bbox : void 0;\n    featureId = isFeatureCollection ? geojson.features[i].id : isFeature ? geojson.id : void 0;\n    isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === \"GeometryCollection\" : false;\n    stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n    for (g = 0; g < stopG; g++) {\n      geometry = isGeometryCollection ? geometryMaybeCollection.geometries[g] : geometryMaybeCollection;\n      if (geometry === null) {\n        if (callback(\n          null,\n          featureIndex,\n          featureProperties,\n          featureBBox,\n          featureId\n        ) === false)\n          return false;\n        continue;\n      }\n      switch (geometry.type) {\n        case \"Point\":\n        case \"LineString\":\n        case \"MultiPoint\":\n        case \"Polygon\":\n        case \"MultiLineString\":\n        case \"MultiPolygon\": {\n          if (callback(\n            geometry,\n            featureIndex,\n            featureProperties,\n            featureBBox,\n            featureId\n          ) === false)\n            return false;\n          break;\n        }\n        case \"GeometryCollection\": {\n          for (j = 0; j < geometry.geometries.length; j++) {\n            if (callback(\n              geometry.geometries[j],\n              featureIndex,\n              featureProperties,\n              featureBBox,\n              featureId\n            ) === false)\n              return false;\n          }\n          break;\n        }\n        default:\n          throw new Error(\"Unknown Geometry Type\");\n      }\n    }\n    featureIndex++;\n  }\n}\nfunction geomReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  geomEach(\n    geojson,\n    function(currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n      if (featureIndex === 0 && initialValue === void 0)\n        previousValue = currentGeometry;\n      else\n        previousValue = callback(\n          previousValue,\n          currentGeometry,\n          featureIndex,\n          featureProperties,\n          featureBBox,\n          featureId\n        );\n    }\n  );\n  return previousValue;\n}\nfunction flattenEach(geojson, callback) {\n  geomEach(geojson, function(geometry, featureIndex, properties, bbox, id) {\n    var type = geometry === null ? null : geometry.type;\n    switch (type) {\n      case null:\n      case \"Point\":\n      case \"LineString\":\n      case \"Polygon\":\n        if (callback(\n          feature(geometry, properties, { bbox, id }),\n          featureIndex,\n          0\n        ) === false)\n          return false;\n        return;\n    }\n    var geomType;\n    switch (type) {\n      case \"MultiPoint\":\n        geomType = \"Point\";\n        break;\n      case \"MultiLineString\":\n        geomType = \"LineString\";\n        break;\n      case \"MultiPolygon\":\n        geomType = \"Polygon\";\n        break;\n    }\n    for (var multiFeatureIndex = 0; multiFeatureIndex < geometry.coordinates.length; multiFeatureIndex++) {\n      var coordinate = geometry.coordinates[multiFeatureIndex];\n      var geom = {\n        type: geomType,\n        coordinates: coordinate\n      };\n      if (callback(feature(geom, properties), featureIndex, multiFeatureIndex) === false)\n        return false;\n    }\n  });\n}\nfunction flattenReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  flattenEach(\n    geojson,\n    function(currentFeature, featureIndex, multiFeatureIndex) {\n      if (featureIndex === 0 && multiFeatureIndex === 0 && initialValue === void 0)\n        previousValue = currentFeature;\n      else\n        previousValue = callback(\n          previousValue,\n          currentFeature,\n          featureIndex,\n          multiFeatureIndex\n        );\n    }\n  );\n  return previousValue;\n}\nfunction segmentEach(geojson, callback) {\n  flattenEach(geojson, function(feature2, featureIndex, multiFeatureIndex) {\n    var segmentIndex = 0;\n    if (!feature2.geometry) return;\n    var type = feature2.geometry.type;\n    if (type === \"Point\" || type === \"MultiPoint\") return;\n    var previousCoords;\n    var previousFeatureIndex = 0;\n    var previousMultiIndex = 0;\n    var prevGeomIndex = 0;\n    if (coordEach(\n      feature2,\n      function(currentCoord, coordIndex, featureIndexCoord, multiPartIndexCoord, geometryIndex) {\n        if (previousCoords === void 0 || featureIndex > previousFeatureIndex || multiPartIndexCoord > previousMultiIndex || geometryIndex > prevGeomIndex) {\n          previousCoords = currentCoord;\n          previousFeatureIndex = featureIndex;\n          previousMultiIndex = multiPartIndexCoord;\n          prevGeomIndex = geometryIndex;\n          segmentIndex = 0;\n          return;\n        }\n        var currentSegment = lineString(\n          [previousCoords, currentCoord],\n          feature2.properties\n        );\n        if (callback(\n          currentSegment,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex,\n          segmentIndex\n        ) === false)\n          return false;\n        segmentIndex++;\n        previousCoords = currentCoord;\n      }\n    ) === false)\n      return false;\n  });\n}\nfunction segmentReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  var started = false;\n  segmentEach(\n    geojson,\n    function(currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n      if (started === false && initialValue === void 0)\n        previousValue = currentSegment;\n      else\n        previousValue = callback(\n          previousValue,\n          currentSegment,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex,\n          segmentIndex\n        );\n      started = true;\n    }\n  );\n  return previousValue;\n}\nfunction lineEach(geojson, callback) {\n  if (!geojson) throw new Error(\"geojson is required\");\n  flattenEach(geojson, function(feature2, featureIndex, multiFeatureIndex) {\n    if (feature2.geometry === null) return;\n    var type = feature2.geometry.type;\n    var coords = feature2.geometry.coordinates;\n    switch (type) {\n      case \"LineString\":\n        if (callback(feature2, featureIndex, multiFeatureIndex, 0, 0) === false)\n          return false;\n        break;\n      case \"Polygon\":\n        for (var geometryIndex = 0; geometryIndex < coords.length; geometryIndex++) {\n          if (callback(\n            lineString(coords[geometryIndex], feature2.properties),\n            featureIndex,\n            multiFeatureIndex,\n            geometryIndex\n          ) === false)\n            return false;\n        }\n        break;\n    }\n  });\n}\nfunction lineReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  lineEach(\n    geojson,\n    function(currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n      if (featureIndex === 0 && initialValue === void 0)\n        previousValue = currentLine;\n      else\n        previousValue = callback(\n          previousValue,\n          currentLine,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex\n        );\n    }\n  );\n  return previousValue;\n}\nfunction findSegment(geojson, options) {\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var featureIndex = options.featureIndex || 0;\n  var multiFeatureIndex = options.multiFeatureIndex || 0;\n  var geometryIndex = options.geometryIndex || 0;\n  var segmentIndex = options.segmentIndex || 0;\n  var properties = options.properties;\n  var geometry;\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      if (featureIndex < 0)\n        featureIndex = geojson.features.length + featureIndex;\n      properties = properties || geojson.features[featureIndex].properties;\n      geometry = geojson.features[featureIndex].geometry;\n      break;\n    case \"Feature\":\n      properties = properties || geojson.properties;\n      geometry = geojson.geometry;\n      break;\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n    case \"Polygon\":\n    case \"MultiLineString\":\n    case \"MultiPolygon\":\n      geometry = geojson;\n      break;\n    default:\n      throw new Error(\"geojson is invalid\");\n  }\n  if (geometry === null) return null;\n  var coords = geometry.coordinates;\n  switch (geometry.type) {\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n      if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;\n      return lineString(\n        [coords[segmentIndex], coords[segmentIndex + 1]],\n        properties,\n        options\n      );\n    case \"Polygon\":\n      if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n      if (segmentIndex < 0)\n        segmentIndex = coords[geometryIndex].length + segmentIndex - 1;\n      return lineString(\n        [\n          coords[geometryIndex][segmentIndex],\n          coords[geometryIndex][segmentIndex + 1]\n        ],\n        properties,\n        options\n      );\n    case \"MultiLineString\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (segmentIndex < 0)\n        segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;\n      return lineString(\n        [\n          coords[multiFeatureIndex][segmentIndex],\n          coords[multiFeatureIndex][segmentIndex + 1]\n        ],\n        properties,\n        options\n      );\n    case \"MultiPolygon\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (geometryIndex < 0)\n        geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n      if (segmentIndex < 0)\n        segmentIndex = coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;\n      return lineString(\n        [\n          coords[multiFeatureIndex][geometryIndex][segmentIndex],\n          coords[multiFeatureIndex][geometryIndex][segmentIndex + 1]\n        ],\n        properties,\n        options\n      );\n  }\n  throw new Error(\"geojson is invalid\");\n}\nfunction findPoint(geojson, options) {\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var featureIndex = options.featureIndex || 0;\n  var multiFeatureIndex = options.multiFeatureIndex || 0;\n  var geometryIndex = options.geometryIndex || 0;\n  var coordIndex = options.coordIndex || 0;\n  var properties = options.properties;\n  var geometry;\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      if (featureIndex < 0)\n        featureIndex = geojson.features.length + featureIndex;\n      properties = properties || geojson.features[featureIndex].properties;\n      geometry = geojson.features[featureIndex].geometry;\n      break;\n    case \"Feature\":\n      properties = properties || geojson.properties;\n      geometry = geojson.geometry;\n      break;\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n    case \"Polygon\":\n    case \"MultiLineString\":\n    case \"MultiPolygon\":\n      geometry = geojson;\n      break;\n    default:\n      throw new Error(\"geojson is invalid\");\n  }\n  if (geometry === null) return null;\n  var coords = geometry.coordinates;\n  switch (geometry.type) {\n    case \"Point\":\n      return point(coords, properties, options);\n    case \"MultiPoint\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      return point(coords[multiFeatureIndex], properties, options);\n    case \"LineString\":\n      if (coordIndex < 0) coordIndex = coords.length + coordIndex;\n      return point(coords[coordIndex], properties, options);\n    case \"Polygon\":\n      if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n      if (coordIndex < 0)\n        coordIndex = coords[geometryIndex].length + coordIndex;\n      return point(coords[geometryIndex][coordIndex], properties, options);\n    case \"MultiLineString\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (coordIndex < 0)\n        coordIndex = coords[multiFeatureIndex].length + coordIndex;\n      return point(coords[multiFeatureIndex][coordIndex], properties, options);\n    case \"MultiPolygon\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (geometryIndex < 0)\n        geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n      if (coordIndex < 0)\n        coordIndex = coords[multiFeatureIndex][geometryIndex].length - coordIndex;\n      return point(\n        coords[multiFeatureIndex][geometryIndex][coordIndex],\n        properties,\n        options\n      );\n  }\n  throw new Error(\"geojson is invalid\");\n}\nexport {\n  coordAll,\n  coordEach,\n  coordReduce,\n  featureEach,\n  featureReduce,\n  findPoint,\n  findSegment,\n  flattenEach,\n  flattenReduce,\n  geomEach,\n  geomReduce,\n  lineEach,\n  lineReduce,\n  propEach,\n  propReduce,\n  segmentEach,\n  segmentReduce\n};\n//# sourceMappingURL=index.js.map","// index.ts\nimport { distance } from \"@turf/distance\";\nimport { segmentReduce } from \"@turf/meta\";\nfunction length(geojson, options = {}) {\n  return segmentReduce(\n    geojson,\n    (previousValue, segment) => {\n      const coords = segment.geometry.coordinates;\n      return previousValue + distance(coords[0], coords[1], options);\n    },\n    0\n  );\n}\nvar turf_length_default = length;\nexport {\n  turf_length_default as default,\n  length\n};\n//# sourceMappingURL=index.js.map","import {along} from '@turf/along';\nimport {length} from '@turf/length';\nimport Map from '../src/ol/Map.js';\nimport View from '../src/ol/View.js';\nimport GeoJSON from '../src/ol/format/GeoJSON.js';\nimport TileLayer from '../src/ol/layer/Tile.js';\nimport VectorLayer from '../src/ol/layer/Vector.js';\nimport {fromLonLat} from '../src/ol/proj.js';\nimport OSM from '../src/ol/source/OSM.js';\nimport VectorSource from '../src/ol/source/Vector.js';\n\nconst source = new VectorSource();\nfetch('data/geojson/roads-seoul.geojson')\n  .then(function (response) {\n    return response.json();\n  })\n  .then(function (json) {\n    const format = new GeoJSON();\n    const features = format.readFeatures(json);\n    const street = features[0];\n\n    // convert to a turf.js feature\n    const turfLine = format.writeFeatureObject(street);\n\n    // show a marker every 200 meters\n    const distance = 0.2;\n\n    // get the line length in kilometers\n    const lineLength = length(turfLine, {units: 'kilometers'});\n    for (let i = 1; i <= lineLength / distance; i++) {\n      const turfPoint = along(turfLine, i * distance, {units: 'kilometers'});\n\n      // convert the generated point to a OpenLayers feature\n      const marker = format.readFeature(turfPoint);\n      marker.getGeometry().transform('EPSG:4326', 'EPSG:3857');\n      source.addFeature(marker);\n    }\n\n    street.getGeometry().transform('EPSG:4326', 'EPSG:3857');\n    source.addFeature(street);\n  });\nconst vectorLayer = new VectorLayer({\n  source: source,\n});\n\nconst rasterLayer = new TileLayer({\n  source: new OSM(),\n});\n\nconst map = new Map({\n  layers: [rasterLayer, vectorLayer],\n  target: document.getElementById('map'),\n  view: new View({\n    center: fromLonLat([126.980366, 37.52654]),\n    zoom: 15,\n  }),\n});\n"],"names":["earthRadius","factors","centimeters","centimetres","degrees","Math","PI","feet","inches","kilometers","kilometres","meters","metres","miles","millimeters","millimetres","nauticalmiles","radians","yards","feature","geom","properties","options","feat","type","id","bbox","geometry","coordinates","Error","Array","isArray","length","radiansToLength","units","factor","lengthToRadians","distance","radiansToDegrees","degreesToRadians","num","isNaN","getCoord","coord","bearing","start","end","final","bear","calculateFinalBearing","coordinates1","coordinates2","lon1","lon2","lat1","lat2","a","sin","cos","b","atan2","destination","origin","longitude1","latitude1","bearingRad","latitude2","asin","from","to","dLat","dLon","pow","sqrt","along","line","geojson","coords","travelled","i","overshot","direction","coordEach","callback","excludeWrapCoord","j","k","l","stopG","geometryMaybeCollection","isGeometryCollection","wrapShrink","coordIndex","isFeatureCollection","isFeature","stop","features","featureIndex","geometries","geomIndex","multiFeatureIndex","geometryIndex","geomType","geomEach","g","featureProperties","featureBBox","featureId","flattenEach","coordinate","segmentReduce","initialValue","previousValue","started","feature2","segmentIndex","previousCoords","previousFeatureIndex","previousMultiIndex","prevGeomIndex","currentCoord","featureIndexCoord","multiPartIndexCoord","currentSegment","segmentEach","segment","source","fetch","then","response","json","format","GeoJSON","street","readFeatures","turfLine","writeFeatureObject","lineLength","turfPoint","marker","readFeature","getGeometry","transform","addFeature","vectorLayer","Vector","rasterLayer","Tile","OSM","Map","layers","target","document","getElementById","view","View","center","zoom"],"sourceRoot":""}