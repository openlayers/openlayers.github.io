{"version":3,"file":"flight-animation.js","mappings":"kOAaA,MAAMA,EAAY,IAAI,IAAU,CAC9BC,OAAQ,IAAI,IAAW,CACrBC,MAAO,mBAILC,EAAM,IAAI,IAAI,CAClBC,OAAQ,CAACJ,GACTK,OAAQ,MACRC,KAAM,IAAI,KAAK,CACbC,OAAQ,EAAE,KAAU,MACpBC,KAAM,MAIJC,EAAQ,IAAI,KAAM,CACtBC,OAAQ,IAAI,IAAO,CACjBC,MAAO,UACPC,MAAO,MAILC,EAAgB,IAAI,IAAa,CACrCC,aACE,8EAEFC,OAAQ,WAENC,MADY,iCAETC,MAAK,SAAUC,GACd,OAAOA,EAASC,MAClB,IACCF,MAAK,SAAUE,GACd,MAAMC,EAAcD,EAAKE,QACzB,IAAK,IAAIC,EAAI,EAAGA,EAAIF,EAAYG,OAAQD,IAAK,CAC3C,MAAME,EAASJ,EAAYE,GACrBG,EAAOD,EAAO,GACdE,EAAKF,EAAO,GAQZG,EALe,IAAIC,IAAIC,YAC3B,CAACC,EAAGL,EAAK,GAAIM,EAAGN,EAAK,IACrB,CAACK,EAAGJ,EAAG,GAAIK,EAAGL,EAAG,KAGUM,IAAI,IAAK,CAACC,OAAQ,KAGzCC,EAAW,GACjBP,EAAQQ,WAAWC,SAAQ,SAAUC,GACnC,MAAMC,EAAO,IAAI,IAAWD,EAASE,QACrCD,EAAKE,UAAU,YAAa,aAE5BN,EAASO,KACP,IAAI,IAAQ,CACVJ,SAAUC,EACVI,UAAU,IAGhB,IAGAC,EAAST,EAAc,GAAJZ,EACrB,CACAtB,EAAU4C,GAAG,aAAcC,EAC7B,GACJ,IAGIC,EAAe,IAAI,IAAY,CACnC7C,OAAQY,EACRJ,MAAO,SAAUsC,GAGf,OAAIA,EAAQC,IAAI,YACPvC,EAEF,IACT,IAGFN,EAAI8C,SAASH,GAEb,MAAMI,EAAc,IACpB,SAASL,EAAeM,GACtB,MAAMC,GAAgB,QAAiBD,GACjCE,EAAaF,EAAME,WACzBD,EAAcE,SAAS7C,GAEvB,MAAMyB,EAAWrB,EAAc0C,cAC/B,IAAK,IAAIjC,EAAI,EAAGA,EAAIY,EAASX,OAAQD,IAAK,CACxC,MAAMyB,EAAUb,EAASZ,GACzB,IAAKyB,EAAQC,IAAI,YAAa,CAE5B,MAAMT,EAASQ,EAAQS,cAAcC,iBAC/BC,EAAcL,EAAWM,KAAOZ,EAAQC,IAAI,SAClD,GAAIU,GAAe,EAAG,CACpB,MAAME,EAAgBF,EAAcR,EAEhCU,GAAiBrB,EAAOhB,QAC1BwB,EAAQc,IAAI,YAAY,GAG1B,MAAMC,EAAWC,KAAKC,IAAIJ,EAAerB,EAAOhB,QAC1C0C,EAAc,IAAI,IAAW1B,EAAO2B,MAAM,EAAGJ,IAG7CK,GAAa,QAAShE,EAAIiE,UAAUC,gBAAgBC,aACpDrC,EAAS8B,KAAKQ,MAAMpE,EAAIiE,UAAUI,YAAY,GAAKL,GAGzDF,EAAYQ,UAAUxC,EAASkC,EAAY,GAC3Cf,EAAcsB,aAAaT,GAC3BA,EAAYQ,UAAUN,EAAY,GAClCf,EAAcsB,aAAaT,EAC7B,CACF,CACF,CAEA9D,EAAIwE,QACN,CAEA,SAAShC,EAAST,EAAU0C,GAC1BC,OAAOC,YAAW,WAChB,IAAIC,EAAQC,KAAKC,MACjB/C,EAASE,SAAQ,SAAUW,GACzBA,EAAQc,IAAI,QAASkB,GACrBlE,EAAcqE,WAAWnC,GACzB,MAAMoC,GACHpC,EAAQS,cAAcC,iBAAiBlC,OAAS,GAAK2B,EACxD6B,GAASI,CACX,GACF,GAAGP,EACL,C","sources":["webpack:///./flight-animation.js"],"sourcesContent":["import Feature from '../src/ol/Feature.js';\nimport Map from '../src/ol/Map.js';\nimport View from '../src/ol/View.js';\nimport {getWidth} from '../src/ol/extent.js';\nimport LineString from '../src/ol/geom/LineString.js';\nimport TileLayer from '../src/ol/layer/Tile.js';\nimport VectorLayer from '../src/ol/layer/Vector.js';\nimport {getVectorContext} from '../src/ol/render.js';\nimport StadiaMaps from '../src/ol/source/StadiaMaps.js';\nimport VectorSource from '../src/ol/source/Vector.js';\nimport Stroke from '../src/ol/style/Stroke.js';\nimport Style from '../src/ol/style/Style.js';\n\nconst tileLayer = new TileLayer({\n  source: new StadiaMaps({\n    layer: 'stamen_toner',\n  }),\n});\n\nconst map = new Map({\n  layers: [tileLayer],\n  target: 'map',\n  view: new View({\n    center: [-11000000, 4600000],\n    zoom: 2,\n  }),\n});\n\nconst style = new Style({\n  stroke: new Stroke({\n    color: '#EAE911',\n    width: 2,\n  }),\n});\n\nconst flightsSource = new VectorSource({\n  attributions:\n    'Flight data by ' +\n    '<a href=\"https://openflights.org/data.html\">OpenFlights</a>,',\n  loader: function () {\n    const url = 'data/openflights/flights.json';\n    fetch(url)\n      .then(function (response) {\n        return response.json();\n      })\n      .then(function (json) {\n        const flightsData = json.flights;\n        for (let i = 0; i < flightsData.length; i++) {\n          const flight = flightsData[i];\n          const from = flight[0];\n          const to = flight[1];\n\n          // create an arc circle between the two locations\n          const arcGenerator = new arc.GreatCircle(\n            {x: from[1], y: from[0]},\n            {x: to[1], y: to[0]},\n          );\n\n          const arcLine = arcGenerator.Arc(100, {offset: 10});\n          // paths which cross the -180°/+180° meridian are split\n          // into two sections which will be animated sequentially\n          const features = [];\n          arcLine.geometries.forEach(function (geometry) {\n            const line = new LineString(geometry.coords);\n            line.transform('EPSG:4326', 'EPSG:3857');\n\n            features.push(\n              new Feature({\n                geometry: line,\n                finished: false,\n              }),\n            );\n          });\n          // add the features with a delay so that the animation\n          // for all features does not start at the same time\n          addLater(features, i * 50);\n        }\n        tileLayer.on('postrender', animateFlights);\n      });\n  },\n});\n\nconst flightsLayer = new VectorLayer({\n  source: flightsSource,\n  style: function (feature) {\n    // if the animation is still active for a feature, do not\n    // render the feature with the layer style\n    if (feature.get('finished')) {\n      return style;\n    }\n    return null;\n  },\n});\n\nmap.addLayer(flightsLayer);\n\nconst pointsPerMs = 0.02;\nfunction animateFlights(event) {\n  const vectorContext = getVectorContext(event);\n  const frameState = event.frameState;\n  vectorContext.setStyle(style);\n\n  const features = flightsSource.getFeatures();\n  for (let i = 0; i < features.length; i++) {\n    const feature = features[i];\n    if (!feature.get('finished')) {\n      // only draw the lines for which the animation has not finished yet\n      const coords = feature.getGeometry().getCoordinates();\n      const elapsedTime = frameState.time - feature.get('start');\n      if (elapsedTime >= 0) {\n        const elapsedPoints = elapsedTime * pointsPerMs;\n\n        if (elapsedPoints >= coords.length) {\n          feature.set('finished', true);\n        }\n\n        const maxIndex = Math.min(elapsedPoints, coords.length);\n        const currentLine = new LineString(coords.slice(0, maxIndex));\n\n        // animation is needed in the current and nearest adjacent wrapped world\n        const worldWidth = getWidth(map.getView().getProjection().getExtent());\n        const offset = Math.floor(map.getView().getCenter()[0] / worldWidth);\n\n        // directly draw the lines with the vector context\n        currentLine.translate(offset * worldWidth, 0);\n        vectorContext.drawGeometry(currentLine);\n        currentLine.translate(worldWidth, 0);\n        vectorContext.drawGeometry(currentLine);\n      }\n    }\n  }\n  // tell OpenLayers to continue the animation\n  map.render();\n}\n\nfunction addLater(features, timeout) {\n  window.setTimeout(function () {\n    let start = Date.now();\n    features.forEach(function (feature) {\n      feature.set('start', start);\n      flightsSource.addFeature(feature);\n      const duration =\n        (feature.getGeometry().getCoordinates().length - 1) / pointsPerMs;\n      start += duration;\n    });\n  }, timeout);\n}\n"],"names":["tileLayer","source","layer","map","layers","target","view","center","zoom","style","stroke","color","width","flightsSource","attributions","loader","fetch","then","response","json","flightsData","flights","i","length","flight","from","to","arcLine","arc","GreatCircle","x","y","Arc","offset","features","geometries","forEach","geometry","line","coords","transform","push","finished","addLater","on","animateFlights","flightsLayer","feature","get","addLayer","pointsPerMs","event","vectorContext","frameState","setStyle","getFeatures","getGeometry","getCoordinates","elapsedTime","time","elapsedPoints","set","maxIndex","Math","min","currentLine","slice","worldWidth","getView","getProjection","getExtent","floor","getCenter","translate","drawGeometry","render","timeout","window","setTimeout","start","Date","now","addFeature","duration"],"sourceRoot":""}