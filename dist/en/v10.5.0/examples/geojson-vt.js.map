{"version":3,"file":"geojson-vt.js","mappings":"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","sources":["webpack:///../node_modules/geojson-vt/src/simplify.js","webpack:///../node_modules/geojson-vt/src/feature.js","webpack:///../node_modules/geojson-vt/src/convert.js","webpack:///../node_modules/geojson-vt/src/clip.js","webpack:///../node_modules/geojson-vt/src/wrap.js","webpack:///../node_modules/geojson-vt/src/transform.js","webpack:///../node_modules/geojson-vt/src/tile.js","webpack:///../node_modules/geojson-vt/src/index.js","webpack:///./geojson-vt.js"],"sourcesContent":["\n// calculate simplification data using optimized Douglas-Peucker algorithm\n\nexport default function simplify(coords, first, last, sqTolerance) {\n    let maxSqDist = sqTolerance;\n    const mid = first + ((last - first) >> 1);\n    let minPosToMid = last - first;\n    let index;\n\n    const ax = coords[first];\n    const ay = coords[first + 1];\n    const bx = coords[last];\n    const by = coords[last + 1];\n\n    for (let i = first + 3; i < last; i += 3) {\n        const d = getSqSegDist(coords[i], coords[i + 1], ax, ay, bx, by);\n\n        if (d > maxSqDist) {\n            index = i;\n            maxSqDist = d;\n\n        } else if (d === maxSqDist) {\n            // a workaround to ensure we choose a pivot close to the middle of the list,\n            // reducing recursion depth, for certain degenerate inputs\n            // https://github.com/mapbox/geojson-vt/issues/104\n            const posToMid = Math.abs(i - mid);\n            if (posToMid < minPosToMid) {\n                index = i;\n                minPosToMid = posToMid;\n            }\n        }\n    }\n\n    if (maxSqDist > sqTolerance) {\n        if (index - first > 3) simplify(coords, first, index, sqTolerance);\n        coords[index + 2] = maxSqDist;\n        if (last - index > 3) simplify(coords, index, last, sqTolerance);\n    }\n}\n\n// square distance from a point to a segment\nfunction getSqSegDist(px, py, x, y, bx, by) {\n\n    let dx = bx - x;\n    let dy = by - y;\n\n    if (dx !== 0 || dy !== 0) {\n\n        const t = ((px - x) * dx + (py - y) * dy) / (dx * dx + dy * dy);\n\n        if (t > 1) {\n            x = bx;\n            y = by;\n\n        } else if (t > 0) {\n            x += dx * t;\n            y += dy * t;\n        }\n    }\n\n    dx = px - x;\n    dy = py - y;\n\n    return dx * dx + dy * dy;\n}\n","\nexport default function createFeature(id, type, geom, tags) {\n    const feature = {\n        id: id == null ? null : id,\n        type,\n        geometry: geom,\n        tags,\n        minX: Infinity,\n        minY: Infinity,\n        maxX: -Infinity,\n        maxY: -Infinity\n    };\n\n    if (type === 'Point' || type === 'MultiPoint' || type === 'LineString') {\n        calcLineBBox(feature, geom);\n\n    } else if (type === 'Polygon') {\n        // the outer ring (ie [0]) contains all inner rings\n        calcLineBBox(feature, geom[0]);\n\n    } else if (type === 'MultiLineString') {\n        for (const line of geom) {\n            calcLineBBox(feature, line);\n        }\n\n    } else if (type === 'MultiPolygon') {\n        for (const polygon of geom) {\n            // the outer ring (ie [0]) contains all inner rings\n            calcLineBBox(feature, polygon[0]);\n        }\n    }\n\n    return feature;\n}\n\nfunction calcLineBBox(feature, geom) {\n    for (let i = 0; i < geom.length; i += 3) {\n        feature.minX = Math.min(feature.minX, geom[i]);\n        feature.minY = Math.min(feature.minY, geom[i + 1]);\n        feature.maxX = Math.max(feature.maxX, geom[i]);\n        feature.maxY = Math.max(feature.maxY, geom[i + 1]);\n    }\n}\n","\nimport simplify from './simplify.js';\nimport createFeature from './feature.js';\n\n// converts GeoJSON feature into an intermediate projected JSON vector format with simplification data\n\nexport default function convert(data, options) {\n    const features = [];\n    if (data.type === 'FeatureCollection') {\n        for (let i = 0; i < data.features.length; i++) {\n            convertFeature(features, data.features[i], options, i);\n        }\n\n    } else if (data.type === 'Feature') {\n        convertFeature(features, data, options);\n\n    } else {\n        // single geometry or a geometry collection\n        convertFeature(features, {geometry: data}, options);\n    }\n\n    return features;\n}\n\nfunction convertFeature(features, geojson, options, index) {\n    if (!geojson.geometry) return;\n\n    const coords = geojson.geometry.coordinates;\n    if (coords && coords.length === 0) return;\n\n    const type = geojson.geometry.type;\n    const tolerance = Math.pow(options.tolerance / ((1 << options.maxZoom) * options.extent), 2);\n    let geometry = [];\n    let id = geojson.id;\n    if (options.promoteId) {\n        id = geojson.properties[options.promoteId];\n    } else if (options.generateId) {\n        id = index || 0;\n    }\n    if (type === 'Point') {\n        convertPoint(coords, geometry);\n\n    } else if (type === 'MultiPoint') {\n        for (const p of coords) {\n            convertPoint(p, geometry);\n        }\n\n    } else if (type === 'LineString') {\n        convertLine(coords, geometry, tolerance, false);\n\n    } else if (type === 'MultiLineString') {\n        if (options.lineMetrics) {\n            // explode into linestrings to be able to track metrics\n            for (const line of coords) {\n                geometry = [];\n                convertLine(line, geometry, tolerance, false);\n                features.push(createFeature(id, 'LineString', geometry, geojson.properties));\n            }\n            return;\n        } else {\n            convertLines(coords, geometry, tolerance, false);\n        }\n\n    } else if (type === 'Polygon') {\n        convertLines(coords, geometry, tolerance, true);\n\n    } else if (type === 'MultiPolygon') {\n        for (const polygon of coords) {\n            const newPolygon = [];\n            convertLines(polygon, newPolygon, tolerance, true);\n            geometry.push(newPolygon);\n        }\n    } else if (type === 'GeometryCollection') {\n        for (const singleGeometry of geojson.geometry.geometries) {\n            convertFeature(features, {\n                id,\n                geometry: singleGeometry,\n                properties: geojson.properties\n            }, options, index);\n        }\n        return;\n    } else {\n        throw new Error('Input data is not a valid GeoJSON object.');\n    }\n\n    features.push(createFeature(id, type, geometry, geojson.properties));\n}\n\nfunction convertPoint(coords, out) {\n    out.push(projectX(coords[0]), projectY(coords[1]), 0);\n}\n\nfunction convertLine(ring, out, tolerance, isPolygon) {\n    let x0, y0;\n    let size = 0;\n\n    for (let j = 0; j < ring.length; j++) {\n        const x = projectX(ring[j][0]);\n        const y = projectY(ring[j][1]);\n\n        out.push(x, y, 0);\n\n        if (j > 0) {\n            if (isPolygon) {\n                size += (x0 * y - x * y0) / 2; // area\n            } else {\n                size += Math.sqrt(Math.pow(x - x0, 2) + Math.pow(y - y0, 2)); // length\n            }\n        }\n        x0 = x;\n        y0 = y;\n    }\n\n    const last = out.length - 3;\n    out[2] = 1;\n    simplify(out, 0, last, tolerance);\n    out[last + 2] = 1;\n\n    out.size = Math.abs(size);\n    out.start = 0;\n    out.end = out.size;\n}\n\nfunction convertLines(rings, out, tolerance, isPolygon) {\n    for (let i = 0; i < rings.length; i++) {\n        const geom = [];\n        convertLine(rings[i], geom, tolerance, isPolygon);\n        out.push(geom);\n    }\n}\n\nfunction projectX(x) {\n    return x / 360 + 0.5;\n}\n\nfunction projectY(y) {\n    const sin = Math.sin(y * Math.PI / 180);\n    const y2 = 0.5 - 0.25 * Math.log((1 + sin) / (1 - sin)) / Math.PI;\n    return y2 < 0 ? 0 : y2 > 1 ? 1 : y2;\n}\n","\nimport createFeature from './feature.js';\n\n/* clip features between two vertical or horizontal axis-parallel lines:\n *     |        |\n *  ___|___     |     /\n * /   |   \\____|____/\n *     |        |\n *\n * k1 and k2 are the line coordinates\n * axis: 0 for x, 1 for y\n * minAll and maxAll: minimum and maximum coordinate value for all features\n */\nexport default function clip(features, scale, k1, k2, axis, minAll, maxAll, options) {\n    k1 /= scale;\n    k2 /= scale;\n\n    if (minAll >= k1 && maxAll < k2) return features; // trivial accept\n    else if (maxAll < k1 || minAll >= k2) return null; // trivial reject\n\n    const clipped = [];\n\n    for (const feature of features) {\n        const geometry = feature.geometry;\n        let type = feature.type;\n\n        const min = axis === 0 ? feature.minX : feature.minY;\n        const max = axis === 0 ? feature.maxX : feature.maxY;\n\n        if (min >= k1 && max < k2) { // trivial accept\n            clipped.push(feature);\n            continue;\n        } else if (max < k1 || min >= k2) { // trivial reject\n            continue;\n        }\n\n        let newGeometry = [];\n\n        if (type === 'Point' || type === 'MultiPoint') {\n            clipPoints(geometry, newGeometry, k1, k2, axis);\n\n        } else if (type === 'LineString') {\n            clipLine(geometry, newGeometry, k1, k2, axis, false, options.lineMetrics);\n\n        } else if (type === 'MultiLineString') {\n            clipLines(geometry, newGeometry, k1, k2, axis, false);\n\n        } else if (type === 'Polygon') {\n            clipLines(geometry, newGeometry, k1, k2, axis, true);\n\n        } else if (type === 'MultiPolygon') {\n            for (const polygon of geometry) {\n                const newPolygon = [];\n                clipLines(polygon, newPolygon, k1, k2, axis, true);\n                if (newPolygon.length) {\n                    newGeometry.push(newPolygon);\n                }\n            }\n        }\n\n        if (newGeometry.length) {\n            if (options.lineMetrics && type === 'LineString') {\n                for (const line of newGeometry) {\n                    clipped.push(createFeature(feature.id, type, line, feature.tags));\n                }\n                continue;\n            }\n\n            if (type === 'LineString' || type === 'MultiLineString') {\n                if (newGeometry.length === 1) {\n                    type = 'LineString';\n                    newGeometry = newGeometry[0];\n                } else {\n                    type = 'MultiLineString';\n                }\n            }\n            if (type === 'Point' || type === 'MultiPoint') {\n                type = newGeometry.length === 3 ? 'Point' : 'MultiPoint';\n            }\n\n            clipped.push(createFeature(feature.id, type, newGeometry, feature.tags));\n        }\n    }\n\n    return clipped.length ? clipped : null;\n}\n\nfunction clipPoints(geom, newGeom, k1, k2, axis) {\n    for (let i = 0; i < geom.length; i += 3) {\n        const a = geom[i + axis];\n\n        if (a >= k1 && a <= k2) {\n            addPoint(newGeom, geom[i], geom[i + 1], geom[i + 2]);\n        }\n    }\n}\n\nfunction clipLine(geom, newGeom, k1, k2, axis, isPolygon, trackMetrics) {\n\n    let slice = newSlice(geom);\n    const intersect = axis === 0 ? intersectX : intersectY;\n    let len = geom.start;\n    let segLen, t;\n\n    for (let i = 0; i < geom.length - 3; i += 3) {\n        const ax = geom[i];\n        const ay = geom[i + 1];\n        const az = geom[i + 2];\n        const bx = geom[i + 3];\n        const by = geom[i + 4];\n        const a = axis === 0 ? ax : ay;\n        const b = axis === 0 ? bx : by;\n        let exited = false;\n\n        if (trackMetrics) segLen = Math.sqrt(Math.pow(ax - bx, 2) + Math.pow(ay - by, 2));\n\n        if (a < k1) {\n            // ---|-->  | (line enters the clip region from the left)\n            if (b > k1) {\n                t = intersect(slice, ax, ay, bx, by, k1);\n                if (trackMetrics) slice.start = len + segLen * t;\n            }\n        } else if (a > k2) {\n            // |  <--|--- (line enters the clip region from the right)\n            if (b < k2) {\n                t = intersect(slice, ax, ay, bx, by, k2);\n                if (trackMetrics) slice.start = len + segLen * t;\n            }\n        } else {\n            addPoint(slice, ax, ay, az);\n        }\n        if (b < k1 && a >= k1) {\n            // <--|---  | or <--|-----|--- (line exits the clip region on the left)\n            t = intersect(slice, ax, ay, bx, by, k1);\n            exited = true;\n        }\n        if (b > k2 && a <= k2) {\n            // |  ---|--> or ---|-----|--> (line exits the clip region on the right)\n            t = intersect(slice, ax, ay, bx, by, k2);\n            exited = true;\n        }\n\n        if (!isPolygon && exited) {\n            if (trackMetrics) slice.end = len + segLen * t;\n            newGeom.push(slice);\n            slice = newSlice(geom);\n        }\n\n        if (trackMetrics) len += segLen;\n    }\n\n    // add the last point\n    let last = geom.length - 3;\n    const ax = geom[last];\n    const ay = geom[last + 1];\n    const az = geom[last + 2];\n    const a = axis === 0 ? ax : ay;\n    if (a >= k1 && a <= k2) addPoint(slice, ax, ay, az);\n\n    // close the polygon if its endpoints are not the same after clipping\n    last = slice.length - 3;\n    if (isPolygon && last >= 3 && (slice[last] !== slice[0] || slice[last + 1] !== slice[1])) {\n        addPoint(slice, slice[0], slice[1], slice[2]);\n    }\n\n    // add the final slice\n    if (slice.length) {\n        newGeom.push(slice);\n    }\n}\n\nfunction newSlice(line) {\n    const slice = [];\n    slice.size = line.size;\n    slice.start = line.start;\n    slice.end = line.end;\n    return slice;\n}\n\nfunction clipLines(geom, newGeom, k1, k2, axis, isPolygon) {\n    for (const line of geom) {\n        clipLine(line, newGeom, k1, k2, axis, isPolygon, false);\n    }\n}\n\nfunction addPoint(out, x, y, z) {\n    out.push(x, y, z);\n}\n\nfunction intersectX(out, ax, ay, bx, by, x) {\n    const t = (x - ax) / (bx - ax);\n    addPoint(out, x, ay + (by - ay) * t, 1);\n    return t;\n}\n\nfunction intersectY(out, ax, ay, bx, by, y) {\n    const t = (y - ay) / (by - ay);\n    addPoint(out, ax + (bx - ax) * t, y, 1);\n    return t;\n}\n","\nimport clip from './clip.js';\nimport createFeature from './feature.js';\n\nexport default function wrap(features, options) {\n    const buffer = options.buffer / options.extent;\n    let merged = features;\n    const left  = clip(features, 1, -1 - buffer, buffer,     0, -1, 2, options); // left world copy\n    const right = clip(features, 1,  1 - buffer, 2 + buffer, 0, -1, 2, options); // right world copy\n\n    if (left || right) {\n        merged = clip(features, 1, -buffer, 1 + buffer, 0, -1, 2, options) || []; // center world copy\n\n        if (left) merged = shiftFeatureCoords(left, 1).concat(merged); // merge left into center\n        if (right) merged = merged.concat(shiftFeatureCoords(right, -1)); // merge right into center\n    }\n\n    return merged;\n}\n\nfunction shiftFeatureCoords(features, offset) {\n    const newFeatures = [];\n\n    for (let i = 0; i < features.length; i++) {\n        const feature = features[i];\n        const type = feature.type;\n\n        let newGeometry;\n\n        if (type === 'Point' || type === 'MultiPoint' || type === 'LineString') {\n            newGeometry = shiftCoords(feature.geometry, offset);\n\n        } else if (type === 'MultiLineString' || type === 'Polygon') {\n            newGeometry = [];\n            for (const line of feature.geometry) {\n                newGeometry.push(shiftCoords(line, offset));\n            }\n        } else if (type === 'MultiPolygon') {\n            newGeometry = [];\n            for (const polygon of feature.geometry) {\n                const newPolygon = [];\n                for (const line of polygon) {\n                    newPolygon.push(shiftCoords(line, offset));\n                }\n                newGeometry.push(newPolygon);\n            }\n        }\n\n        newFeatures.push(createFeature(feature.id, type, newGeometry, feature.tags));\n    }\n\n    return newFeatures;\n}\n\nfunction shiftCoords(points, offset) {\n    const newPoints = [];\n    newPoints.size = points.size;\n\n    if (points.start !== undefined) {\n        newPoints.start = points.start;\n        newPoints.end = points.end;\n    }\n\n    for (let i = 0; i < points.length; i += 3) {\n        newPoints.push(points[i] + offset, points[i + 1], points[i + 2]);\n    }\n    return newPoints;\n}\n","\n// Transforms the coordinates of each feature in the given tile from\n// mercator-projected space into (extent x extent) tile space.\nexport default function transformTile(tile, extent) {\n    if (tile.transformed) return tile;\n\n    const z2 = 1 << tile.z;\n    const tx = tile.x;\n    const ty = tile.y;\n\n    for (const feature of tile.features) {\n        const geom = feature.geometry;\n        const type = feature.type;\n\n        feature.geometry = [];\n\n        if (type === 1) {\n            for (let j = 0; j < geom.length; j += 2) {\n                feature.geometry.push(transformPoint(geom[j], geom[j + 1], extent, z2, tx, ty));\n            }\n        } else {\n            for (let j = 0; j < geom.length; j++) {\n                const ring = [];\n                for (let k = 0; k < geom[j].length; k += 2) {\n                    ring.push(transformPoint(geom[j][k], geom[j][k + 1], extent, z2, tx, ty));\n                }\n                feature.geometry.push(ring);\n            }\n        }\n    }\n\n    tile.transformed = true;\n\n    return tile;\n}\n\nfunction transformPoint(x, y, extent, z2, tx, ty) {\n    return [\n        Math.round(extent * (x * z2 - tx)),\n        Math.round(extent * (y * z2 - ty))];\n}\n","\nexport default function createTile(features, z, tx, ty, options) {\n    const tolerance = z === options.maxZoom ? 0 : options.tolerance / ((1 << z) * options.extent);\n    const tile = {\n        features: [],\n        numPoints: 0,\n        numSimplified: 0,\n        numFeatures: features.length,\n        source: null,\n        x: tx,\n        y: ty,\n        z,\n        transformed: false,\n        minX: 2,\n        minY: 1,\n        maxX: -1,\n        maxY: 0\n    };\n    for (const feature of features) {\n        addFeature(tile, feature, tolerance, options);\n    }\n    return tile;\n}\n\nfunction addFeature(tile, feature, tolerance, options) {\n    const geom = feature.geometry;\n    const type = feature.type;\n    const simplified = [];\n\n    tile.minX = Math.min(tile.minX, feature.minX);\n    tile.minY = Math.min(tile.minY, feature.minY);\n    tile.maxX = Math.max(tile.maxX, feature.maxX);\n    tile.maxY = Math.max(tile.maxY, feature.maxY);\n\n    if (type === 'Point' || type === 'MultiPoint') {\n        for (let i = 0; i < geom.length; i += 3) {\n            simplified.push(geom[i], geom[i + 1]);\n            tile.numPoints++;\n            tile.numSimplified++;\n        }\n\n    } else if (type === 'LineString') {\n        addLine(simplified, geom, tile, tolerance, false, false);\n\n    } else if (type === 'MultiLineString' || type === 'Polygon') {\n        for (let i = 0; i < geom.length; i++) {\n            addLine(simplified, geom[i], tile, tolerance, type === 'Polygon', i === 0);\n        }\n\n    } else if (type === 'MultiPolygon') {\n\n        for (let k = 0; k < geom.length; k++) {\n            const polygon = geom[k];\n            for (let i = 0; i < polygon.length; i++) {\n                addLine(simplified, polygon[i], tile, tolerance, true, i === 0);\n            }\n        }\n    }\n\n    if (simplified.length) {\n        let tags = feature.tags || null;\n\n        if (type === 'LineString' && options.lineMetrics) {\n            tags = {};\n            for (const key in feature.tags) tags[key] = feature.tags[key];\n            tags['mapbox_clip_start'] = geom.start / geom.size;\n            tags['mapbox_clip_end'] = geom.end / geom.size;\n        }\n\n        const tileFeature = {\n            geometry: simplified,\n            type: type === 'Polygon' || type === 'MultiPolygon' ? 3 :\n            (type === 'LineString' || type === 'MultiLineString' ? 2 : 1),\n            tags\n        };\n        if (feature.id !== null) {\n            tileFeature.id = feature.id;\n        }\n        tile.features.push(tileFeature);\n    }\n}\n\nfunction addLine(result, geom, tile, tolerance, isPolygon, isOuter) {\n    const sqTolerance = tolerance * tolerance;\n\n    if (tolerance > 0 && (geom.size < (isPolygon ? sqTolerance : tolerance))) {\n        tile.numPoints += geom.length / 3;\n        return;\n    }\n\n    const ring = [];\n\n    for (let i = 0; i < geom.length; i += 3) {\n        if (tolerance === 0 || geom[i + 2] > sqTolerance) {\n            tile.numSimplified++;\n            ring.push(geom[i], geom[i + 1]);\n        }\n        tile.numPoints++;\n    }\n\n    if (isPolygon) rewind(ring, isOuter);\n\n    result.push(ring);\n}\n\nfunction rewind(ring, clockwise) {\n    let area = 0;\n    for (let i = 0, len = ring.length, j = len - 2; i < len; j = i, i += 2) {\n        area += (ring[i] - ring[j]) * (ring[i + 1] + ring[j + 1]);\n    }\n    if (area > 0 === clockwise) {\n        for (let i = 0, len = ring.length; i < len / 2; i += 2) {\n            const x = ring[i];\n            const y = ring[i + 1];\n            ring[i] = ring[len - 2 - i];\n            ring[i + 1] = ring[len - 1 - i];\n            ring[len - 2 - i] = x;\n            ring[len - 1 - i] = y;\n        }\n    }\n}\n","\nimport convert from './convert.js';     // GeoJSON conversion and preprocessing\nimport clip from './clip.js';           // stripe clipping algorithm\nimport wrap from './wrap.js';           // date line processing\nimport transform from './transform.js'; // coordinate transformation\nimport createTile from './tile.js';     // final simplified tile generation\n\nconst defaultOptions = {\n    maxZoom: 14,            // max zoom to preserve detail on\n    indexMaxZoom: 5,        // max zoom in the tile index\n    indexMaxPoints: 100000, // max number of points per tile in the tile index\n    tolerance: 3,           // simplification tolerance (higher means simpler)\n    extent: 4096,           // tile extent\n    buffer: 64,             // tile buffer on each side\n    lineMetrics: false,     // whether to calculate line metrics\n    promoteId: null,        // name of a feature property to be promoted to feature.id\n    generateId: false,      // whether to generate feature ids. Cannot be used with promoteId\n    debug: 0                // logging level (0, 1 or 2)\n};\n\nclass GeoJSONVT {\n    constructor(data, options) {\n        options = this.options = extend(Object.create(defaultOptions), options);\n\n        const debug = options.debug;\n\n        if (debug) console.time('preprocess data');\n\n        if (options.maxZoom < 0 || options.maxZoom > 24) throw new Error('maxZoom should be in the 0-24 range');\n        if (options.promoteId && options.generateId) throw new Error('promoteId and generateId cannot be used together.');\n\n        // projects and adds simplification info\n        let features = convert(data, options);\n\n        // tiles and tileCoords are part of the public API\n        this.tiles = {};\n        this.tileCoords = [];\n\n        if (debug) {\n            console.timeEnd('preprocess data');\n            console.log('index: maxZoom: %d, maxPoints: %d', options.indexMaxZoom, options.indexMaxPoints);\n            console.time('generate tiles');\n            this.stats = {};\n            this.total = 0;\n        }\n\n        // wraps features (ie extreme west and extreme east)\n        features = wrap(features, options);\n\n        // start slicing from the top tile down\n        if (features.length) this.splitTile(features, 0, 0, 0);\n\n        if (debug) {\n            if (features.length) console.log('features: %d, points: %d', this.tiles[0].numFeatures, this.tiles[0].numPoints);\n            console.timeEnd('generate tiles');\n            console.log('tiles generated:', this.total, JSON.stringify(this.stats));\n        }\n    }\n\n    // splits features from a parent tile to sub-tiles.\n    // z, x, and y are the coordinates of the parent tile\n    // cz, cx, and cy are the coordinates of the target tile\n    //\n    // If no target tile is specified, splitting stops when we reach the maximum\n    // zoom or the number of points is low as specified in the options.\n    splitTile(features, z, x, y, cz, cx, cy) {\n\n        const stack = [features, z, x, y];\n        const options = this.options;\n        const debug = options.debug;\n\n        // avoid recursion by using a processing queue\n        while (stack.length) {\n            y = stack.pop();\n            x = stack.pop();\n            z = stack.pop();\n            features = stack.pop();\n\n            const z2 = 1 << z;\n            const id = toID(z, x, y);\n            let tile = this.tiles[id];\n\n            if (!tile) {\n                if (debug > 1) console.time('creation');\n\n                tile = this.tiles[id] = createTile(features, z, x, y, options);\n                this.tileCoords.push({z, x, y});\n\n                if (debug) {\n                    if (debug > 1) {\n                        console.log('tile z%d-%d-%d (features: %d, points: %d, simplified: %d)',\n                            z, x, y, tile.numFeatures, tile.numPoints, tile.numSimplified);\n                        console.timeEnd('creation');\n                    }\n                    const key = `z${  z}`;\n                    this.stats[key] = (this.stats[key] || 0) + 1;\n                    this.total++;\n                }\n            }\n\n            // save reference to original geometry in tile so that we can drill down later if we stop now\n            tile.source = features;\n\n            // if it's the first-pass tiling\n            if (cz == null) {\n                // stop tiling if we reached max zoom, or if the tile is too simple\n                if (z === options.indexMaxZoom || tile.numPoints <= options.indexMaxPoints) continue;\n            // if a drilldown to a specific tile\n            } else if (z === options.maxZoom || z === cz) {\n                // stop tiling if we reached base zoom or our target tile zoom\n                continue;\n            } else if (cz != null) {\n                // stop tiling if it's not an ancestor of the target tile\n                const zoomSteps = cz - z;\n                if (x !== cx >> zoomSteps || y !== cy >> zoomSteps) continue;\n            }\n\n            // if we slice further down, no need to keep source geometry\n            tile.source = null;\n\n            if (features.length === 0) continue;\n\n            if (debug > 1) console.time('clipping');\n\n            // values we'll use for clipping\n            const k1 = 0.5 * options.buffer / options.extent;\n            const k2 = 0.5 - k1;\n            const k3 = 0.5 + k1;\n            const k4 = 1 + k1;\n\n            let tl = null;\n            let bl = null;\n            let tr = null;\n            let br = null;\n\n            let left  = clip(features, z2, x - k1, x + k3, 0, tile.minX, tile.maxX, options);\n            let right = clip(features, z2, x + k2, x + k4, 0, tile.minX, tile.maxX, options);\n            features = null;\n\n            if (left) {\n                tl = clip(left, z2, y - k1, y + k3, 1, tile.minY, tile.maxY, options);\n                bl = clip(left, z2, y + k2, y + k4, 1, tile.minY, tile.maxY, options);\n                left = null;\n            }\n\n            if (right) {\n                tr = clip(right, z2, y - k1, y + k3, 1, tile.minY, tile.maxY, options);\n                br = clip(right, z2, y + k2, y + k4, 1, tile.minY, tile.maxY, options);\n                right = null;\n            }\n\n            if (debug > 1) console.timeEnd('clipping');\n\n            stack.push(tl || [], z + 1, x * 2,     y * 2);\n            stack.push(bl || [], z + 1, x * 2,     y * 2 + 1);\n            stack.push(tr || [], z + 1, x * 2 + 1, y * 2);\n            stack.push(br || [], z + 1, x * 2 + 1, y * 2 + 1);\n        }\n    }\n\n    getTile(z, x, y) {\n        z = +z;\n        x = +x;\n        y = +y;\n\n        const options = this.options;\n        const {extent, debug} = options;\n\n        if (z < 0 || z > 24) return null;\n\n        const z2 = 1 << z;\n        x = (x + z2) & (z2 - 1); // wrap tile x coordinate\n\n        const id = toID(z, x, y);\n        if (this.tiles[id]) return transform(this.tiles[id], extent);\n\n        if (debug > 1) console.log('drilling down to z%d-%d-%d', z, x, y);\n\n        let z0 = z;\n        let x0 = x;\n        let y0 = y;\n        let parent;\n\n        while (!parent && z0 > 0) {\n            z0--;\n            x0 = x0 >> 1;\n            y0 = y0 >> 1;\n            parent = this.tiles[toID(z0, x0, y0)];\n        }\n\n        if (!parent || !parent.source) return null;\n\n        // if we found a parent tile containing the original geometry, we can drill down from it\n        if (debug > 1) {\n            console.log('found parent tile z%d-%d-%d', z0, x0, y0);\n            console.time('drilling down');\n        }\n        this.splitTile(parent.source, z0, x0, y0, z, x, y);\n        if (debug > 1) console.timeEnd('drilling down');\n\n        return this.tiles[id] ? transform(this.tiles[id], extent) : null;\n    }\n}\n\nfunction toID(z, x, y) {\n    return (((1 << z) * y + x) * 32) + z;\n}\n\nfunction extend(dest, src) {\n    for (const i in src) dest[i] = src[i];\n    return dest;\n}\n\nexport default function geojsonvt(data, options) {\n    return new GeoJSONVT(data, options);\n}\n","import geojsonvt from 'geojson-vt';\nimport Map from '../src/ol/Map.js';\nimport View from '../src/ol/View.js';\nimport GeoJSON from '../src/ol/format/GeoJSON.js';\nimport VectorTileLayer from '../src/ol/layer/VectorTile.js';\nimport Projection from '../src/ol/proj/Projection.js';\nimport VectorTileSource from '../src/ol/source/VectorTile.js';\n\n// Converts geojson-vt data to GeoJSON\nconst replacer = function (key, value) {\n  if (!value || !value.geometry) {\n    return value;\n  }\n\n  let type;\n  const rawType = value.type;\n  let geometry = value.geometry;\n  if (rawType === 1) {\n    type = 'MultiPoint';\n    if (geometry.length == 1) {\n      type = 'Point';\n      geometry = geometry[0];\n    }\n  } else if (rawType === 2) {\n    type = 'MultiLineString';\n    if (geometry.length == 1) {\n      type = 'LineString';\n      geometry = geometry[0];\n    }\n  } else if (rawType === 3) {\n    type = 'Polygon';\n    if (geometry.length > 1) {\n      type = 'MultiPolygon';\n      geometry = [geometry];\n    }\n  }\n\n  return {\n    'type': 'Feature',\n    'geometry': {\n      'type': type,\n      'coordinates': geometry,\n    },\n    'properties': value.tags,\n  };\n};\n\nconst layer = new VectorTileLayer({\n  background: '#1a2b39',\n  style: {\n    'fill-color': ['string', ['get', 'COLOR'], '#eee'],\n  },\n});\n\nconst map = new Map({\n  layers: [layer],\n  target: 'map',\n  view: new View({\n    center: [0, 0],\n    zoom: 2,\n  }),\n});\n\nconst url = 'https://openlayers.org/data/vector/ecoregions.json';\nfetch(url)\n  .then(function (response) {\n    return response.json();\n  })\n  .then(function (json) {\n    const tileIndex = geojsonvt(json, {\n      extent: 4096,\n      debug: 1,\n    });\n    const format = new GeoJSON({\n      // Data returned from geojson-vt is in tile pixel units\n      dataProjection: new Projection({\n        code: 'TILE_PIXELS',\n        units: 'tile-pixels',\n        extent: [0, 0, 4096, 4096],\n      }),\n    });\n    const vectorSource = new VectorTileSource({\n      tileUrlFunction: function (tileCoord) {\n        // Use the tile coordinate as a pseudo URL for caching purposes\n        return JSON.stringify(tileCoord);\n      },\n      tileLoadFunction: function (tile, url) {\n        const tileCoord = JSON.parse(url);\n        const data = tileIndex.getTile(\n          tileCoord[0],\n          tileCoord[1],\n          tileCoord[2],\n        );\n        const geojson = JSON.stringify(\n          {\n            type: 'FeatureCollection',\n            features: data ? data.features : [],\n          },\n          replacer,\n        );\n        const features = format.readFeatures(geojson, {\n          extent: vectorSource.getTileGrid().getTileCoordExtent(tileCoord),\n          featureProjection: map.getView().getProjection(),\n        });\n        tile.setFeatures(features);\n      },\n    });\n    layer.setSource(vectorSource);\n  });\n"],"names":["simplify","coords","first","last","sqTolerance","maxSqDist","mid","index","minPosToMid","ax","ay","bx","by","i","d","getSqSegDist","posToMid","Math","abs","px","py","x","y","dx","dy","t","createFeature","id","type","geom","tags","feature","geometry","minX","Infinity","minY","maxX","maxY","calcLineBBox","line","polygon","length","min","max","convertFeature","features","geojson","options","coordinates","tolerance","pow","maxZoom","extent","promoteId","properties","generateId","convertPoint","p","convertLine","lineMetrics","push","convertLines","singleGeometry","geometries","Error","newPolygon","out","projectX","projectY","ring","isPolygon","x0","y0","size","j","sqrt","start","end","rings","sin","PI","y2","log","clip","scale","k1","k2","axis","minAll","maxAll","clipped","newGeometry","clipPoints","clipLine","clipLines","newGeom","a","addPoint","trackMetrics","slice","newSlice","intersect","intersectX","intersectY","segLen","len","az","b","exited","z","shiftFeatureCoords","offset","newFeatures","shiftCoords","points","newPoints","undefined","transformTile","tile","transformed","z2","tx","ty","transformPoint","k","round","createTile","numPoints","numSimplified","numFeatures","source","addFeature","simplified","addLine","key","tileFeature","result","isOuter","clockwise","area","rewind","defaultOptions","indexMaxZoom","indexMaxPoints","buffer","debug","GeoJSONVT","constructor","data","this","dest","src","extend","Object","create","console","time","convert","tiles","tileCoords","timeEnd","stats","total","merged","left","right","concat","wrap","splitTile","JSON","stringify","cz","cx","cy","stack","pop","toID","zoomSteps","k3","k4","tl","bl","tr","br","getTile","parent","z0","replacer","value","rawType","VectorTile","background","style","map","Map","layers","target","view","View","center","zoom","fetch","then","response","json","tileIndex","format","GeoJSON","dataProjection","Projection","code","units","vectorSource","tileUrlFunction","tileCoord","tileLoadFunction","url","parse","readFeatures","getTileGrid","getTileCoordExtent","featureProjection","getView","getProjection","setFeatures","setSource"],"sourceRoot":""}